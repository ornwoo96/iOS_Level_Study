

# Level 0

## 1. 컴퓨터 시스템에서 CPU, RAM, 저장 장치의 역할과 이들이 어떻게 상호 작용하는지 설명해주세요.

<img src="https://github.com/user-attachments/assets/b7748bfe-fdb5-4655-b153-f15388fdff0e">

### CPU (Central Processing Unit)
**역할 :**
- 컴퓨터의 중앙 처리 장치. 컴퓨터의 두뇌

**특징 :**
- 시스템의 명령어를 해석하고 실행
- 모든 연산과 논리 처리 담당
- 직렬(순차)처리 방식에 특화된 구조
- CPU는 연산장치(ALU) / 제어 장치(Control Unit) / 레지스터 로 구성

**장치 설명 :**
- 연산장치(ALU) :
  - 산술 및 논리 연산을 수행. 예) 덧셈, 뺄셈, 곱셈, 나눗셈 등
- 제어 장치 :
  - 프로그램 명령어를 해석
  - 명령어의 실행 순서를 제어
- 레지스터 :
  - CPU 내부의 매우 빠른 메모리
  - 현재 처리 중인 데이터와 주소를 임시 저장
 
**상호 작용 :**
- CPU는 시스템 버스를 통해 RAM과 저장장치와 연결
- 데이터와 명령어를 RAM에서 가져와 처리하고, 필요시 결과를 저장장치에 저장

<br>

<img src="https://github.com/user-attachments/assets/a009896e-e2d9-4643-a047-71c57062d41c">

### RAM (Random Access Memory)
**역할 :**
- 컴퓨터의 주기억 장치

**특징 :**
- 휘발성 메모리
- 데이터 임시 저장 :
  - 프로그램 실행 중 필요한 데이터와 명령어를 일시적으로 저장 
  - 프로그램이 실행 될때 :
    - 프로그램의 데이터와 명령어는 하드 디스크에서 RAM 으로 로드되어 CPU에 의해 처리
  - 프로그램과 데이터를 저장하는 용도로는 적합하지 않음
- 빠른 접근 속도 :
  - CPU가 빠르게 접근할 수 있도록 자주 사용되는 데이터와 명령어를 저장하는 데 적합
  - RAM은 HDD 나 SSD 보다 훨씬 빠른 속도로 데이터에 접근 가능 -> CPU와의 데이터 교환에 적합
 
**상호 작용 :**
- CPU는 RAM에 있는 데이터를 읽고 쓰며, RAM은 프로그램 실행 중 필요한 데이터를 빠르게 제공하여 CPU의 성능을 최적화
- RAM의 내용은 전원이 꺼지면 사라짐

<br>

<img src="https://github.com/user-attachments/assets/dcf454c0-050e-4217-b401-ecfbce371281">


### 저장 장치 (HDD-하드 디스크 드라이브 / SSD-솔리드 스테이트 드라이브)
**역할 :**
- 데이터와 프로그램의 영구적 저장

**특징 :**
- 비휘발성 메모리
- 데이터 영구 저장 :
  - 운영 체제, 애플리케이션, 사용자 파일 등을 영구적 저장
  - 전원이 꺼져도 데이터 유지
- 느린 접근 속도 :
  - HDD는 물리적 디스크를 회전시켜 데이터를 읽고 쓰는 방식 
  - SSD는 반도체를 사용하여 HDD보다 빠름
  - 그러나 둘다 RAM에 비해 느림

**상호 작용 :**
- CPU와 RAM의 데이터를 영구적으로 저장하거나 필요할 때 불러오는 역할을 합니다.
- 운영체제, 애플리케이션, 사용자 데이터 등이 저장됩니다.

<br>
<br>

## 1.1 CPU와 메모리 간의 데이터 교환은 어떻게 이루어지나요?


<img src="https://github.com/user-attachments/assets/88dec934-898e-4e0c-845c-8194a5d49710">

CPU와 메모리 간의 데이터 교환은 **버스(Bus)** 라는 통로를 통해 이루어집니다.

<br>

**단계 :**
1. 주소 지정(Addressing)
- CPU는 데이터 또는 명령어가 저장된 메모리의 특정 위치에 접근해야 합니다.
- 이를 위해 **주소 버스(Address Bus)** 를 통해 메모리 주소를 전송하여 필요한 데이터의 위치를 지정합니다.
<br>

2. 명령어 및 데이터 페치(Fetch)
- CPU는 메모리에 있는 명령어 또는 데이터를 가져오기 위해 **데이터 버스(Data Bus)** 를 사용합니다.
- CPU가 필요한 데이터가 메모리에서 RAM으로 전송되며, CPU는 이를 가져와 연산을 준비합니다.
<br>

3. 연산(Execute)
- 데이터를 메모리에서 가져오면, CPU는 연산을 수행합니다.
- 연산은 CPU의 **연산 장치(ALU)** 에서 이루어지며, 산술 연산 또는 논리 연산을 처리하게 됩니다.
<br>

4. 저장(Store)
- 연산 결과가 나오면, CPU는 이 결과를 다시 메모리에 저장할 수 있습니다.
- 이를 위해 데이터 버스를 통해 데이터를 메모리의 특정 주소로 전송하며, 이 주소 정보는 주소 버스를 통해 전달됩니다.
<br>

5. 제어(Control)
- 이 모든 데이터 교환 과정은 **제어 버스(Control Bus)** 를 통해 관리됩니다.
- 제어 버스는 CPU가 메모리와의 데이터 전송을 동기화하고 제어 신호를 보내는 역할을 합니다.
- 예를 들어, 읽기/쓰기 신호나 인터럽트 신호를 통해 데이터 교환의 타이밍과 순서를 조정합니다.


<br>

**요약 :**
- 버스 시스템을 통해 CPU와 메모리는 효율적으로 데이터를 주고 받으며 컴퓨터의 다양한 작업을 수행할 수 있음
- CPU와 메모리 간의 데이터 교환은 주소 버스, 데이터 버스, 제어 버스를 통해 이루어짐
- 주소 지정 -> 데이터/명령어 페치 -> 연산 -> 저장 |<< 과정을 반복하여 프로그램을 실행

<br>
<br>

## 1.2 버스(Bus)란 무엇이며, 어떤 종류가 있나요?

**컴퓨터 내부에서 데이터를 전달하는 통로** 로, CPU, 메모리, 저장 장치, 입출력 장치 간의 데이터 교환을 가능하게 함
다양한 구성 요소가 데이터를 주고 받는 통신 경로를 제공
주소, 데이터, 제어 신호를 포함한 여러 정보를 전송할 수 있음

<br>

### 버스의 종류
#### 1. 주소 버스 (Address Bus)
#### 역할 :
- CPU가 메모리 또는 다른 장치에 접근할 때, 접근하고자 하는 위치(주소)를 전달

#### 특징 :
- 주소 버스는 단방향으로 작동하여 CPU에서 메모리나 장치로 주소 정보를 전송
- 버스의 폭은(비트 수)은 CPU가 접근할 수 있는 메모리 용량을 결정
- 예) 32비트 주소 버스는 최대 4GB의 메모리 공간을 주소 지정 가능

<br>

#### 2. 데이터 버스 (Data Bus)
#### 역할 :
- CPU와 메모리 또는 다른 장치 간의 데이터 전송을 담당

<br>

#### 특징 :
- 데이터 버스는 양방향으로 작동하여 CPU와 메모리간, 또는 CPU와 장치 간의 데이터를 주고 받을 수 있음
- 데이터 버스의 폭(비트 수)은 한 번에 전송할 수 있는 데이터의 크기를 결정
- 버스 폭이 넓을 수 록 데이터를 더 많이, 더 빠르게 전송할 수 있음

<br>

#### 3. 제어 버스
#### 역할 :
- 제어 신호를 전달하여 각 장치의 동작을 관리
- 데이터 전송의 타이밍과 방향을 조정

<br>

#### 특징 :
- 제어 버스는 읽기/쓰기 신호, 인터럽트 요청, 클럭 신호 등을 포함
- CPU와 메모리, 주변 장치 간의 동작을 동기화 하는 역할
- CPU가 데이터를 읽거나 쓰는 작업을 제대로 수행할 수 있도록 지원

<br>

> #### 인터럽트 요청:
> - CPU가 중요한 외부 요청(예: 입력, 네트워크 신호 등)을 빠르게 처리할 수 있도록 하는 신호.
> #### 클럭 신호:
> - CPU와 시스템의 모든 구성 요소가 동기화된 속도로 동작하도록 조절하는 신호로, CPU의 성능과 속도를 결정합니다.

<br>

### 요약 :
- 주소 버스: 데이터 위치(주소)를 지정하기 위해 사용되는 단방향 버스
- 데이터 버스: CPU와 메모리, 주변 장치 간의 실제 데이터를 전송하는 양방향 버스
- 제어 버스: 동작을 관리하고 신호를 통해 각 장치의 통신을 제어하는 버스


<br>
<br>



## 2. **캐시 메모리의 개념과 역할에 대해 설명해주세요.**

<img src = "https://github.com/user-attachments/assets/f68cfaff-5269-419b-8a83-743325806ea1">

#### 개념 :
캐시 메모리는 CPU와 메인 메모리(RAM) 사이에 위치한 고속의 소형 메모리로, 자주 사용하는 데이터나 명령어를 임시로 저장하여 CPU의 처리속도를 높이는 역할을 함. 캐시는 CPU가 자주 접근하는 데이터를 빠르게 제공하여, CPU가 메인 메모리의 느린 접근 속도로 인해 발생하는 지연 시간을 줄이는 데 중요한 역할을 함
- 고속 메모리 :
  - 캐시 메모리는 RAM 보다 훨씬 빠르지만, 용량이 작음
  - CPU와 가까운 위치에 있어 데이터 전송 속도가 빠름
- 임시 저장소 :
  - 자주 사용되거나 가까운 시일 내에 다시 필요할 것으로 예상되는 데이터를 일시적으로 저장
  - 캐시는 데이터를 RAM에 저장하는 대신 빠르게 CPU에 전달합니다.
- 계층 구조 :
  - 캐시는 보통 여러 계층 (L1, L2, L3)으로 구성
  - L1 :
    -  CPU 내부에 내장되어 있으며 가장 빠르고 용량이 적음
  - L2, L3 :
    - 용량이 그보다 크고 조금 더 느린 캐시
   
<br>

#### 역할 :
캐시 메모리는 CPU의 성능 향상을 위해 다음과 같은 역할을 함
- 데이터 접근 속도 향상 :
  - 캐시 메모리는 이러한 데이터를 CPU에 가까이 위치시켜, 자주 사용하는 데이터에 대한 접근 시간을 줄임
- 메모리 병목 현상 완화 :
  - 메인 메모리(RAM)보다 빠르게 접근할 수 있어, CPU가 메모리 속도에 구애받지 않고 연속적으로 작업을 수행할 수 있게함
  - 이를 통해 CPU가 메모리 병목 없이 데이터 처리할 수 있게 도움
- 전력 소비 절감 :
  - CPU가 RAM 대신 캐시에서 데이터를 빠르게 가져오면, 메모리에 접근할 때보다 전력을 덜 소모할 수 있어 시스템의 에너지 효율이 높아짐
 
<br>

#### 캐시 히트(Cache Hit)와 캐시 미스(Cache Miss)

- 캐시 히트(Cache Hit):
  - CPU가 요청한 데이터가 캐시에 존재하여, RAM에 접근하지 않고 바로 CPU로 전달되는 경우를 말합니다.
  - 캐시 히트가 발생하면 데이터 접근 속도가 빨라집니다.
- 캐시 미스(Cache Miss):
  - CPU가 요청한 데이터가 캐시에 없는 경우로, 이때는 메인 메모리(RAM)에서 데이터를 가져와 캐시에 저장하고, CPU에 전달해야 합니다.
  - 캐시 미스가 발생하면 데이터 접근 속도가 느려집니다.


<br>
<br>

## 2.1 캐시의 지역성(Locality) 원리에 대해 설명해주세요.
**캐시의 지역성(Locality) 원리** 는 컴퓨터 시스템에서 데이터를 접근할 때, 특정 패턴을 활용하여 데이터 접근 속도를 향샹시키는 원리입니다.
캐시 메모리는 이 지역성 원리를 기반으로 작동하며, 자주 또는 연속적으로 사용하는 데이터를 미리 캐시에 저장해 CPU의 데이터 접근 시간을 줄입니다. 지역성 원리는 크게 두가지, **시간적 지역성 / 공간적 지역성** 으로 나뉩니다.

<br>

#### 시간적 지역성 (Temporal Locality) :
시간적 지역성은 **최근에 사용된 데이터가 가까운 시간 내에 다시 사용될 가능성이 높다** 는 원리 입니다.
예를 들어, 루프(loop)나 함수에서 사용되는 변수나 데이터는 반복적으로 접근되기 때문에 시간적 지역성을 따릅니다.
- 예시 :
  - 프로그램이 특정 변수를 한 번 사용한 후, 이후에 여러 번 더 참조할 경우, 이 변수는 시간적 지역성을 가진다.
- 캐시 활용 :
  - 캐시는 최근에 사용한 데이터를 저장하여, 동일한 데이터에 다시 접근할 때 캐시에서 빠르게 가져올 수 있도록 합니다.
  - 이로 인해 RAM 접근을 줄일 수 있어 효율이 높아짐
 
<br>

#### 공간적 지역성 (Spatial Locality)
공간적 지역성은 **특정 메모리 위치에 접근할 때, 그 위치와 인접한 메모리 위치도 곧 접근할 가능성이 높다** 는 원리 입니다. 프로그램에서 배열이나 연속된 메모리 블록을 사용하는 경우 공간적 지역성이 발생합니다.
- 예시 :
  - 배열을 순차적으로 탐색하거나, 코드가 연속적인 메모리 위치에 있는 명령어를 순서대로 실행할 경우, 해당 데이터들은 공간적 지역성을 갖음
- 캐시 활용 :
  - 캐시는 데이터나 명령어를 가져올 때 인접한 메모리 블록을 함께 가져와 저장합니다.
  - 이를 통해, 인접 데이터에 접근할 때도 빠르게 데이터를 제공할 수 있어 성능이 향상
 
<br>

#### 지역성 원리가 캐시에 미치는 영향
캐시 메모리는 지역성 원리에 따라 데이터를 캐시에 저장하고 관리합니다. 데이터 접근 패턴이 시간적 및 공간적 지역성을 잘 따를수록 캐시 히트(Cache Hit)율이 높아지며, CPU는 데이터 접근 시간을 줄이고 성능을 극대화할 수 있습니다. 반면, 데이터 접근 패턴이 지역성을 따르지 않을 경우 캐시 미스(Cache Miss)율이 높아져 캐시의 성능이 떨어질 수 있습니다.

<br>

#### 요약
- 시간적 지역성 : 최근 사용된 데이터가 다시 사용될 가능성이 높음
- 공간적 지역성 : 특정 위치의 데이터에 접근할 때 인접 데이터도 함께 접근할 가능성이 높음


<br>
<br>



## 3. CPU 아키텍처의 종류(예: ARM, x86)와 각 특징에 대해 설명해주세요.

CPU 아키텍처는 CPU가 데이터를 처리하고 명령어를 실행하는 방식과 구조를 정의합니다.

<br>


<img src="https://github.com/user-attachments/assets/70fa0118-4d9c-4978-b46c-ccd66ebc7ed5">

### x86 아키텍처
**x86** 아키텍처는 **인텔** 이 개발한 아키텍처로, 주로 데스크탑과 서버에 사용됩니다.
이 아키텍처는 **복잡한 명령어 집합 컴퓨터(CISC, Complex Instruction Set Computing)** 구조를 따르며, 다양한 명령어와 기능을 포함하고 있습니다.

<br>

#### 특징 :
- CISC 구조 :
  - x86 아키텍처는 복잡한 명령어 집합을 제공, 한 명령어가 여러 단계를 처리 가능
- 고성능 :
  - 복잡한 명령어와 높은 처리 성능 덕분에, 데스크톱, 서버, 워크스테이션 등 고성능이 요구되는 환경에 적합
- 높은 전력 소비 :
  - 많은 명령어와 복잡한 회로 구조로 인해 전력 소비가 높아 모바일 기기보다는 주로 데스크톱과 서버 환경에서 사용
- 소트프웨어 호환성 :
  - x86은 오래전부터 널리 사용되어 왔기 때문에, Windows와 linux 같은 다양한 운영체제와 소프트웨어에서 폭 넓게 지원

<br>

#### 대표 프로세서:
- Intel Core 시리즈
- AMD Ryzen 시리즈

<br>


<img src="https://github.com/user-attachments/assets/cf945b92-a279-4cb0-8a68-c34da1b9b829">


### ARM 아키텍처
**ARM** 아키텍처는 **Advanced RISC Machine** 의 약자로, 모바일 기기와 같은 저전력 환경을 위한 **간단한 명령어 집합 컴퓨터(RISC, Reduced Instruction Set Computing)** 구조를 따릅니다. ARM은 간단한 명령어를 빠르게 처리할 수 있어 전력 효율이 높습니다.

<br>

#### 특징 :
- RISC 구조 :
  - ARM 아키텍처는 명령어 집합이 간단하고, 한 번에 하나의 연산을 수행하는 명령어 구조를 가지고 있어 전력 소모가 적음
  - 배터리 성능이 중요한 모바일 기기에서 매우 유리
- 저전력 :
  - 간단한 명령어 집합과 효율적인 설계 덕분에 전력 소비가 적어 스마트폰, 태블릿, IoT 장치 등에 널리 사용
- 고성능화 :
  - 최근에는 성능이 개선되어 데스크톱과 서버에서도 사용할 수 있게 되었음
  - Apple의 M 칩 시리즈가 ARM 아키텍처를 기반으로 하며, 각 애플 기기에 우수한 성능을 보임
 
<br>

#### 요약
- x86 :
  - 복잡한 명령어 집합을 사용하여 고성능을 제공하며, 데스크톱과 서버에 적합
- ARM :
  - 간단한 명령어 집합으로 저전력 소모와 효율을 강조하며, 모바일 기기 및 배터리 가반 기기에 유리

<br>
<br>

## 4. iOS 기기에서 사용되는 AP(Application Processor)의 특징과 역할에 대해 설명해주세요.
애플의 모바일 및 태블릿 장치에서 **중앙 처리 장치 역할을 담당하는 칩 (CPU)** 으로, 애플 실리콘 실리즈가 대표적입니다.

### AP의 주요 특징
- ARM 기반 설계 :
  - 애플 AP는 ARM 아키텍처를 기반으로 하여 고성능과 저전력을 지원
- Big.LITTLE 구조 :
  - 고성능 코어와 저전력 코어를 조합하여 성능과 배터리 효율을 최적화
- 뉴럴 엔진(Neural Engine) :
  - AI와 머신러닝 작업을 빠르게 처리해 얼굴 인식, 사진 및 비디오 처리, 자연어 처리 등에서 높은 성능을 제공
- 통합 메모리 아키텍처 (Unified Memory Architecture) :
  - CPU, GPU, 뉴럴 엔진이 메모리를 공유하여 데이터 접근 속도가 빠르고 효율적
- 고급 제조 공정 :
  - 5nm, 3nm 공정을 적용해 트랜지스터 밀도가 높고 전력 효율이 뛰어남

<br>

### AP의 역할
- 중앙 처리 :
  - 앱 실행 / 데이터 연산 / UI 반응을 포함한 기기 내 모든 연산을 처리
- 그래픽 처리 :
  - 내장된 GPU를 통해 고화질 영상과 고사양 게임을 부드럽게 구현
  - Metal API를 통해 성능 극대화
- AI와 머신러닝 :
  - 뉴럴 엔진으로 AI 작업을 신속히 처리
  - 사진 편집 / AR / 얼굴 인식 등에 활용
- 저전력 관리 :
  - 고성능을 유지하면서도 배터리 수명을 최적화하여 장시간 사용을 지원


<br>
<br>

## 4.1 SoC(System on a Chip)의 개념은 무엇인가요?

<img src="https://github.com/user-attachments/assets/348c5ce2-450f-43c7-93a5-7506ba239342">


**SoC(System on a Chip)** 는 하나의 칩에 CPU, GPU, 메모리, 뉴럴 엔진, 입출력 장치 등 다양한 시스템 구성 요소를 통합한 반도체를 말합니다.

### SoC의 주요 개념
- 통합 설계 :
  - SoC는 CPU, GPU, 메모리 컨트롤러, AI 연산용 뉴럴 엔진, 이미지 신호 프로세서(ISP)와 같은 다양한 장치를 단일 칩에 포함하여, 전체 시스템의 성능과 효율성을 높입니다.
- 크기 및 전력 효율 :
  -  여러 기능을 하나에 칩에 통합함으로써 부품 크기와 전력 소모를 줄일 수 있어, 스마트폰, 태블릿과 같은 모바일 기기에 특히 적합
- 다양한 기능 :
  - SoC는 단일 칩에서 컴퓨팅, 그래픽 처리, 신호 처리 등 다양한 작업을 수행하여 별도의 칩이 필요 없는 완전한 컴퓨팅 솔루션을 제공

<br>

### SoC의 예시
애플의 A 시리즈 칩 (iPhone, Apple TV)과 M 1,2,3,4 시리즈 칩(Mac, iPad)은 SoC의 대표적인 예로 CPU, GPU, 뉴럴 엔진, 메모리 등이 단일 칩에 통합되어 있어 강력한 성능과 효율성을 갖추고 있습니다. (현재 작성자도 M3 Pro Chip 사용중..😎)



<br>
<br>

## 5. 운영체제의 역할과 iOS의 운영체제 구조에 대해 설명해주세요.
**운영 체제(OS)** 는 컴퓨터 하드웨어와 소프트웨어를 관리하고, 사용자와 시스템 간의 상호작용을 가능하게 하는 소프트웨어입니다. **운영체제의 주요 역할** 과 **iOS의 운영체제 구조** 는 다음과 같습니다.

### 운영체제의 주요 역할
- 하드웨어 관리 :
  - CPU, 메모리, 저장 장치, 입출력 장치 등 하드웨어 자원을 효율적으로 관리
- 프로세스 관리 :
  - 여러 어플리케이션이 동시에 실행될 수 있도록 프로세스를 관리
  - CPU 스케줄링과 메모리 할당 조정
- 메모리 관리 :
  - 각 프로그램이 필요한 메모리를 할당받고 해제하도록 조정하여 메모리 효율성 유지
- 파일 시스템 관리 :
  - 파일 저장, 읽기, 쓰기를 관리하며, 데이터의 무결성과 보안을 유지
- 사용자 인터페이스 제공 :
  - 사용자가 기기와 상호작용할 수 있도록 명령어 인터페이스(CLI)나 그래픽 사용자 인터페이스(GUI)를 제공
- 보안과 접근 제어 :
  - 사용자 인증 및 접근 권한을 제어해 시스템을 보호
  - 데이터를 안전하게 관리
 
<br>

### iOS의 운영체제 구조
iOS는 Apple의 모바일 운영체제로, 효율성과 보안을 유지하면서도 다양한 애플리케이션과 기능을 지원하기 위해 계층 구조로 설계되었습니다. iOS의 주요 계층은 다음과 같습니다.

<br>

#### 코어 OS(Core OS) 
- 하드웨어와 가장 밀접하게 연관된 계층으로, iOS 장치의 전력 관리, 파일 시스템, 보안, 네트워크 기능을 제어
- iOS에서 가상 메모리, 파일 시스템 및 저장 장치 관리와 같은 기본적인 시스템 서비스를 제공
- 다양한 하드웨어와 소프트웨어 간의 안정성과 성능을 보장하기 위해 가장 낮은 수준의 기능을 담당

<br>

#### 코어 서비스(Core Services) 
- 애플리케이션이 기기의 기본 기능에 접근할 수 있도록 하는 다양한 프레임워크와 라이브러리를 포함
- 예를 들어, Core Data는 데이터 관리, Core Location은 위치 서비스, Foundation 프레임워크는 기본 데이터 타입과 유틸리티 기능을 제공
- 네트워크 통신, 블루투스 연결, 위치 정보 등을 관리하며, 개발자가 여러 기능을 쉽게 활용하도록 지원

<br>

#### 미디어(Media)
- 오디오, 비디오, 그래픽 처리를 담당하는 그래픽과 멀티미디어 프레임워크를 포함
- Core Graphics, Core Animation, AVFoundation 등의 프레임워크를 통해 애니메이션, 고해상도 그래픽, 오디오 및 비디오 처리 기능을 제공
- Metal API와 같이 GPU 성능을 최적화하여 고사양 게임이나 멀티미디어 앱이 원활하게 구동될 수 있도록 지원

<br>

#### 코코아 터치(Cocoa Touch)
- 사용자와 상호작용하는 애플리케이션 레이어로, UIKit과 같은 인터페이스 구성 요소 및 제스처, 알림, 멀티태스킹 등을 담당
- 버튼, 테이블 뷰, 알림 등을 포함한 다양한 UI 요소를 제공하여, 사용자가 애플리케이션과 상호작용할 수 있도록 돕음
- Core Motion을 통해 센서 데이터를 활용할 수 있으며, 멀티터치, 터치 감지 등 사용자 인터페이스의 대부분이 이 계층에서 제공

<br>

### 요약 
- 운영체제는 하드웨어와 소프트웨어를 효율적으로 관리하여 사용자에게 원활한 환경을 제공
- iOS는 코어 OS, 코어 서비스, 미디어, 코코아 터치의 계층 구조를 통해 성능과 보안을 유지하면서 다양한 기능을 제공
- iOS의 계층화된 구조는 안정성과 효율성을 높이고, 개발자가 다양한 기능을 쉽게 활용

<br>
<br>

## 5.1 iOS의 샌드박스 구조는 어떻게 동작하나요?

<img src="https://github.com/user-attachments/assets/67aba446-240f-4551-92f1-52f4d2c292b0">

iOS의 샌드박스 구조는 **각 애플리케이션이 독립된 환경에서 실행되도록 하여 보안과 안정성을 보장하는 시스템** 입니다. 
샌드박스는 앱이 다른 앱이나 시스템의 중요한 데이터 및 리소스에 접근하지 못하게 제한하고, 필요 최소한의 권한만을 부여함으로써 보안성과 개인 정보 보호를 강화합니다.

<br>

### iOS 샌드박스 구조의 주요 동작 방식
#### 애플리케이션 별 독립 실행 환경
- iOS는 각 앱을 독립된 샌드박스 안에서 실행
- 이로 인해 각 애플리케이션은 자신만의 파일 시스템을 가지며, 다른 앱의 데이터에 접근할 수 없음
- 앱은 오직 자신이 생성한 데이터나 파일에만 접근할 수 있으며, 시스템 레벨의 데이터나 다른 앱의 파일은 기본적으로 접근이 불가능

<br>

#### 파일 시스템 격리
- 샌드박스 구조에서는 앱마다 독립된 디렉토리 구조가 제공됩니다.
- 앱은 자신의 디렉토리 내에서만 파일을 읽고 쓰기할 수 있고, 이 디렉토리는 앱이 삭제되면 함께 제거됩니다.
- 앱의 샌드박스 파일 시스템은 보통 다음과 같은 영역으로 나뉩니다
  - Documents: 사용자 문서가 저장되는 위치
  - Library: 설정 및 앱 데이터를 저장하는 위치
  - tmp: 임시 파일 저장소, 시스템이 필요시 파일을 자동으로 삭제 가능

<br>

#### 네트워크와 시스템 리소스 접근 제한
- 샌드박스는 앱이 네트워크, 카메라, 마이크, 위치 정보 등 민감한 시스템 리소스에 접근하려 할 때 사용자 권한을 요구하도록 설계되어 있습니다.
- 앱이 처음 실행될 때나 특정 기능을 요청할 때 사용자에게 권한을 요청하며, 사용자가 허용한 권한만 사용할 수 있습니다.

<br>

#### 프로세스 간 통신 제한 (Inter-Process Communication)
- 샌드박스는 앱 간의 직접적인 통신(프로세스 간 통신, IPC)을 차단하여 앱이 서로의 데이터에 직접 접근하지 못하도록 합니다.
- 앱은 URL 스킴, iOS의 앱 확장(extension) 또는 클라우드 서비스를 통해 간접적으로 통신해야 합니다.

<br>

#### 보안과 무결성 보호
- 샌드박스는 코드 서명과 앱 무결성 검사를 통해 보안성을 높입니다.
- iOS는 모든 앱을 App Store를 통해 배포하고, 코드가 변조되지 않았는지 확인하기 위해 코드 서명을 사용합니다.
- 이를 통해 iOS 기기에서 실행되는 모든 앱이 애플이 신뢰하는 코드임을 보장하고, 악성 코드로부터 시스템을 보호합니다.

<br>

### 요약
- iOS의 샌드박스 구조는 앱이 독립된 환경에서 실행되도록 하여, 다른 앱의 데이터와 시스템 리소스에 접근하지 못하도록 제한하는 보안 메커니즘입니다.
- 파일 시스템 격리, 권한 관리, 프로세스 간 통신 제한 등을 통해 보안을 강화하며, 사용자 데이터의 보호와 시스템 안정성을 유지합니다.

<br>
<br>

## 5.2 커널(Kernel)의 역할은 무엇인가요?

<img src="https://github.com/user-attachments/assets/37873b31-e12f-4604-a98b-425371f634e1">


커널은 운영체제의 핵심요소로, **하드웨어와 애플리케이션 소프트웨어 간의 중개 역할** 을 수행합니다.
커널은 **운영체제의 가장 낮은 레벨에서 작동** 하며, **시스템 자원을 관리** 하고, **프로그램이 하드웨어를 안전하고 효율적으로 사용할 수 있도록** 합니다.

<br>

### 커널의 주요 역할
#### 프로세스 관리
- 커널은 프로세스 생성, 종료, 스케줄링을 관리하ㅓ여, 여러 프로그램이 동시에 실행될 수 있도록 함
- 멀티태스킹을 지원해 CPU 가 효율적으로 프로세스를 전환하며 실행할 수 있도록 스케줄링
- 각 프로세스 간에 충돌이 없도록 보호

<br>

#### 메모리 관리
- 메모리 할당과 해제를 통해 각 프로세스가 필요한 메모리를 사용할 수 있도록 관리
- 가상 메모리 기능을 제공하여 물리적 메모리 이상으로 메모리를 확장하여, 메모리 부족 상황에서 효율적으로 처리

<br>

#### 장치 관리 (입출력 관리)
- CPU가 하드웨어 장치(디스크, 네트워크, 입력 장치 등)를 제어할 수 있도록 드라이버를 통해 통신을 관리하고, 효율적인 입출력(I/O) 처리하도록 도움
- 사용자 프로그램이 직접 하드웨어에 접근하지 못하도록 하고, 시스템 호출을 통해 간접적으로 하드웨어에 접근하도록 보안성을 유지

<br>

#### 파일 시스템 관리
- 널은 파일 생성, 삭제, 읽기 및 쓰기와 같은 파일 시스템 작업을 관리
- 파일 시스템을 통해 데이터가 안전하게 저장되고 접근 하게 함
- 여러 프로그램이 파일을 동시에 사용할 수 있도록 지원

<br>

#### 보안과 접근 제어
- 커널은 시스템의 보안과 안정성을 위해 각 프로세스의 권한을 관리
- 프로세스와 사용자 간의 접근을 제어
- 각 프로세스가 할당된 권한 내에서만 자원을 사용할 수 있도록 하여, 시스템을 보호하고 안정성을 유지

<br>

#### 인터럽트 처리
- 커널은 인터럽트가 발생했을 때 이를 처리하여, CPU가 우선순위가 높은 작업을 즉각적으로 처리
- 인터럽트 관리 덕분에 하드웨어와 소프트웨어 이벤트가 원활히 처리

<br>

### 요약 
- 커널은 운영체제의 핵심적인 소프트웨어 계층으로, 프로세스와 메모리, 파일 시스템, 입출력 장치 등을 관리하여 시스템의 자원을 효율적이고 안전하게 운영
- 커널이 하드웨어와 애플리케이션 간의 다리 역할을 함으로써, 사용자가 안전하고 안정적으로 시스템을 사용할 수 있도록 도움

<br>
<br>

## 5.3 다중 태스킹(Multitasking)은 어떻게 지원되나요?

<img src="https://github.com/user-attachments/assets/088beb43-7486-438d-9fd8-6ad10b683fd7">


### 다중 태스팅
- 운영체제가 여러 작업(프로세스 또는 스레드)을 동시에 실행하는 것처럼 관리하는 기능
- CPU 스케줄링과 프로세스 관리를 통해 이루어지며, 시스템이 유휴 상태 없이 연속적으로 작업을 처리할 수 있게 지원

### 다중 태스킹을 지원하는 주요 방식
#### 시분할(Time-sharing) 방식
- 시분할 방식은 CPU의 시간을 여러 프로세스가 짧은 시간 단위로 나눠서 사용하는 방법
- CPU가 특정 시간 동안 하나의 작업을 실행하고, 그다음 작업으로 전환
- 이 짧은 시간 단위를 타임 슬라이스(Time Slice) 또는 **퀀텀(Quantum)**이라 불림
- 사용자에게 여러 작업이 동시에 진행되는 것처럼 보임
- 선점형 스케줄링을 통해 특정 프로세스가 지정된 시간을 초과하면 CPU가 다른 프로세스에 할당
- 이를 통해 시스템 자원이 특정 작업에 독점되지 않고, 균등하게 분배

<br>

#### 프로세스와 스레드 관리
- 운영체제는 프로세스와 스레드를 생성하고 관리함으로써 다중 태스킹을 지원
- 프로세스는 독립적인 작업 단위이며, 각 프로세스는 고유한 메모리 공간을 할당
- 스레드는 프로세스 내의 작은 실행 단위로, 같은 프로세스 내에서 메모리를 공유하면서 실행
- 다중 스레드 환경에서는 한 프로세스가 여러 작업을 동시에 수행할 수 있어, 더 높은 효율성을 제공

<br>

#### CPU 스케줄링 알고리즘
- 운영체제는 다중 태스킹을 효율적으로 처리하기 위해 CPU 스케줄링 알고리즘을 사용하여 프로세스의 우선순위와 실행 순서를 결정
- 주요 스케줄링 알고리즘으로는 라운드 로빈, 우선순위 기반 스케줄링, FCFS(First-Come-First-Serve)
- 라운드 로빈 알고리즘에서는 각 프로세스에 균등한 CPU 시간을 할당하여 공정하게 실행

<br>

#### 메모리 관리
- 여러 프로세스가 동시에 실행되기 위해서는 각 프로세스가 필요한 메모리를 할당받고, 사용이 끝나면 해제되어야 함.
- 운영체제는 가상 메모리와 페이징 기법을 통해 각 프로세스가 독립된 메모리 공간을 사용하는 것처럼 처리함
- 가상 메모리를 통해 실제 물리적 메모리보다 많은 메모리 공간을 사용할 수 있게 하며, 메모리 관리 기법으로 다중 태스킹 환경을 지원

<br>

#### 인터럽트 처리
- 다중 태스킹 환경에서는 다양한 하드웨어나 소프트웨어 이벤트가 비동기적으로 발생
- 인터럽트는 CPU가 특정 작업을 중단하고, 긴급한 작업을 처리할 수 있도록 도와주는 메커니즘
- 운영체제는 인터럽트를 관리하여 우선순위가 높은 작업이 즉시 처리되도록 하며, 이를 통해 여러 작업을 효율적으로 수행


<br>

### 요약
운영체제는 시분할 방식, 프로세스와 스레드 관리, CPU 스케줄링, 메모리 관리, 인터럽트 처리 등을 통해 다중 태스킹을 지원합니다. 이를 통해 여러 작업이 동시에 실행되는 것처럼 보여주며, 시스템의 자원을 효율적으로 관리하여 사용자 경험을 향상시킵니다.


<br>
<br>

## 6. 프로세스와 스레드의 차이점, 그리고 iOS에서의 프로세스와 스레드 관리 방법에 대해 설명해주세요.

<img src="https://github.com/user-attachments/assets/8833a1cd-df8e-4f83-9e2f-2d022477cffa">

### 프로세스와 스레드의 차이점

#### 프로세스 (Process)
프로세스는 독립적인 실행 단위로, 각 프로세스는 고유한 메모리를 사용하며 iOS의 샌드박스 구조로 관리
- 각 프로세스는 고유한 메모리 공간(주소 공간)을 가지며, 다른 프로세스와 메모리를 공유하지 않습니다.
- 독립성을 유지하여 서로 간섭하지 못하게 합니다.
- 프로세스 간 데이터 교환은 어렵기 때문에, 인터프로세스 통신(IPC) 기법을 사용
- 멀티프로세스 환경에서 하나의 프로세스가 종료되더라도 다른 프로세스는 계속 실행

<br>

> Tip. 예전에는 하나의 프로세스가 한가지 일만 함. 그러다가 답답해서 스레드를 만듬 그 이유는 아래에

<br>

#### 스레드 (Thread)
스레드는 프로세스 내의 실행 단위로, 프로세스 내에서 메모리를 공유하며 빠르고 효율적인 작업 처리를 위해 사용됨
- 동일한 프로세스 내의 스레드들은 메모리를 공유하여, 상호작용이 쉽고 데이터 교환이 빠름
- 멀티스레드 환경을 통해 하나의 프로세스에서 여러 작업을 동시에 처리할 수 있으며, 자원을 효율적으로 사용할 수 있음
- 그러나 한 스레드에서 오류가 발생하면, 해당 프로세스 내의 다른 스레드까지 영향을 받음

<br>

### iOS에서의 프로세스와 스레드 관리 방법
iOS는 효율성과 안정성을 극대화하기 위해 프로세스와 스레드 관리를 철저히 합니다.
iOS는 앱이 성능을 최적화하고, 불필요한 자원 소모를 줄일 수 있도록 다양한 프레임워크와 기술을 제공합니다.

#### 프로세스 관리
- iOS는 각 앱을 독립된 샌드박스 환경에서 실행하여, 서로 다른 앱이 독립적으로 작동할 수 있도록 함
- 앱은 **포그라운드(foreground)** 와 **백그라운드(background)** 상태로 전환될 수 있으며, 백그라운드 앱은 시스템 자원을 적게 사용하게 하여 배터리 효율을 높이고 시스템 안정성을 유지
- 필요하지 않은 프로세스는 시스템이 자동으로 종료하여 자원을 해제하며, 사용자 경험을 보장하기 위해 중요한 작업은 계속 유지

<br>

#### 스레드 관리
- iOS는 멀티스레딩을 지원하며, **GCD(Grand Central Dispatch)** 와 **NSOperation** 과 같은 API를 통해 효율적인 스레드 관리를 제공
  - GCD (Grand Central Dispatch):
    - iOS에서 멀티스레드를 관리하는 API로, 백그라운드 작업을 손쉽게 분배하고 관리할 수 있도록 도움
    - GCD는 큐(queue)를 사용해 작업을 동시 또는 직렬로 실행하며, 필요한 경우 메인 스레드에서 UI 업데이트 작업을 처리할 수 있음
  - NSOperation:
    - GCD 위에 구축된 고수준 API로, 의존성, 우선순위 등 세부적인 스레드 관리가 필요한 경우에 사용
    - NSOperationQueue를 사용하면 작업 간의 의존성을 설정하고, 작업이 순서대로 실행되도록 할 수 있음
- 메인 스레드(Main Thread):
  - iOS에서는 UI 작업이 반드시 메인 스레드에서 처리되어야 함
  - 따라서, 백그라운드에서 긴 작업을 수행한 후 UI 업데이트가 필요할 때는 메인 스레드에서 처리해야함

#### 백그라운드 작업 처리
- iOS는 **백그라운드에서 작업을 수행할 수 있는 제한된 시간** 을 제공합니다.
  - 예) 앱이 백그라운드로 전환될 때 짧은 작업은 완료할 수 있으며, 이를 위해 iOS는 background task API를 제공
- 다운로드, 위치 서비스와 같은 지속적인 백그라운드 작업을 필요로 할 경우 Background Modes를 설정하여 시스템의 허가를 받아야함

<br>

### 요약
- 프로세스는 독립적인 실행 단위로, 각 프로세스는 고유한 메모리를 사용하며 iOS의 샌드박스 구조로 관리됨
- 스레드는 프로세스 내의 실행 단위로, 프로세스 내에서 메모리를 공유하며 빠르고 효율적인 작업 처리를 위해 사용됨
- iOS는 GCD와 NSOperation을 통해 멀티스레드 환경을 제공하고, 백그라운드 작업 및 메인 스레드에서의 UI 처리를 체계적으로 관리
- 이를 통해 성능 최적화와 안정성을 동시에 유지

<br>
<br>


## 6.1 멀티스레딩이 필요한 이유는 무엇인가요?

<img src="https://github.com/user-attachments/assets/5082d5cb-8c84-4953-86ed-418e4360f4c0">

멀티스레딩은 한 프로세스 내에서 여러 스레드를 동시에 실행하여 작업을 병렬로 처리하는 방식

<br>

### 멀티스레딩이 필요한 이유
#### 프로그램의 응답성 향상
- 멀티스레딩을 사용하면, 메인 스레드가 긴 작업(예: 네트워크 통신, 파일 입출력) 동안 차단되지 않아, 사용자 인터페이스(UI)가 즉각 반응할 수 있음
  - 예) 모바일 앱에서 사진이나 동영상을 다운로드하면서도, 사용자는 화면을 스크롤하거나 버튼을 누르는 등 다른 작업을 할 수 있음

<br>

#### CPU 자원 최적화
- 멀티코어 CPU 환경에서는 각 코어에서 동시에 여러 스레드를 실행할 수 있어, CPU 자원을 최대한 활용할 수 있음
- 각 코어가 독립적인 스레드를 실행함으로써 여러 작업을 병렬로 수행할 수 있기 때문에 프로그램이 더 빠르고 효율적으로 실행

<br>

#### 복잡한 작업의 병렬 처리
- 큰 작업을 작은 단위로 나누어 여러 스레드에서 병렬로 처리함으로써 처리 시간을 단축
  - 예) 이미지나 비디오 처리를 여러 스레드로 분할해 동시에 처리하면 전체 작업 시간이 줄어듬
- 이를 통해 실시간으로 처리해야 하는 작업이나, 대량의 데이터를 다루는 작업에서 성능이 크게 향상  

<br>

#### 자원 공유와 협업 가능
- 멀티스레딩을 통해 공유 자원을 여러 스레드가 협력하여 사용함으로써 프로그램의 구조와 효율을 개선
  - 예) 웹 서버는 멀티스레딩을 통해 여러 사용자의 요청을 동시에 처리하며, 각 스레드는 데이터를 공유하고 동시에 작업을 진행할 수 있음

<br>

#### 비동기 작업 수행
- 멀티스레딩을 사용하면 네트워크 요청이나 파일 입출력과 같은 비동기 작업을 백그라운드에서 수행 가능
- 메인 스레드는 다른 작업을 계속 처리하고, 백그라운드 작업이 완료되면 결과를 받아서 처리하는 방식으로 동작
  - 예) iOS의 GCD(Grand Central Dispatch)는 멀티스레딩을 통해 비동기적으로 작업을 수행하고, 작업이 완료되면 UI 스레드로 돌아와 업데이트를 처리할 수 있도록 지원

<br>

### 요약
멀티스레딩은 프로그램이 더 빠르게 실행되고 사용자에게 즉각적인 응답을 제공할 수 있도록 합니다. CPU 자원을 최대한 활용하여 성능을 높이고, 긴 작업을 백그라운드에서 처리함으로써 사용자 경험을 개선할 수 있습니다.

<br>
<br>



## 6.2 iOS에서 GCD(Grand Central Dispatch)는 어떤 역할을 하나요?

<img src="https://github.com/user-attachments/assets/905e8deb-45ed-4594-a2d2-e6043c10c0d0">

**GCD(Grand Central Dispatch)** 는 iOS에서 효율적으로 멀티스레딩을 구현하고, 비동기 작업을 간단히 관리할 수 있도록 해주는 저수준의 API

<br>

### GCD의 주요 역할
#### 비동기 작업 처리
- GCD를 사용하면 비동기적으로 작업을 실행할 수 있어, 메인 스레드(UI 스레드)가 긴 작업(예: 네트워크 요청, 파일 다운로드)으로 차단되지 않도록 할 수 있음
- 비동기 작업은 백그라운드에서 실행되며, 완료 후 메인 스레드에서 결과를 처리하게 하여 앱의 응답성을 유지
  
<br>

#### 멀티스레드 관리
- GCD는 개발자가 스레드를 직접 생성하고 관리할 필요 없이, 큐(queue)를 통해 여러 작업을 효율적으로 관리할 수 있게 함
- 작업을 직렬 큐(Serial Queue) 또는 **동시 큐(Concurrent Queue)** 에 추가하여 실행 방식(순차 실행 또는 병렬 실행)을 정할 수 있음
- 이를 통해 멀티코어 프로세서에서 CPU 자원을 최적화하고 작업을 병렬로 수행할 수 있음

<br>

#### 작업 큐 관리
- GCD는 작업 큐를 통해 작업을 관리하고 실행합니다. **작업 큐(Dispatch Queue)** 는 작업이 실행될 순서와 방식을 결정하며, GCD는 큐를 통해 작업을 효율적으로 할당
- GCD의 작업 큐 종류
  - 직렬 큐(Serial Queue): 작업을 하나씩 순차적으로 실행
  - 동시 큐(Concurrent Queue): 여러 작업을 동시에 병렬로 실행
  - 메인 큐(Main Queue): 메인 스레드에서 실행되어, UI 업데이트와 같은 작업을 처리함

<br>

#### 메인 스레드에서의 UI 업데이트
- iOS에서는 UI 관련 작업은 반드시 메인 스레드에서 실행해야 함.
- GCD는 DispatchQueue.main을 통해 비동기 작업 후 UI를 안전하게 업데이트할 수 있도록 지원
  - 예) 백그라운드에서 데이터를 다운로드한 후 메인 스레드에서 UI를 업데이트하는 것이 가능

<br>

#### QoS (Quality of Service) 설정
- GCD는 작업의 **우선순위(Quality of Service, QoS)** 를 설정하여 중요도에 따라 CPU 리소스를 효율적으로 할당할 수 있음
- QoS는 주로 다음과 같은 레벨로 구성
  - User-interactive: UI 업데이트나 사용자와 직접적으로 상호작용하는 작업 (최고 우선순위)
  - User-initiated: 사용자 요청에 의해 발생한 작업으로, 빠른 응답이 필요
  - Utility: 다운로드, 데이터 처리 등 시간 소모가 큰 작업
  - Background: 백그라운드 데이터 업데이트 등 낮은 우선순위의 작업

<br>

```swift

DispatchQueue.global(qos: .userInitiated).async {
    // 백그라운드에서 실행할 작업
    
    DispatchQueue.main.async {
        // 메인 스레드에서 실행할 작업 (예: UI 업데이트)
    }
}

```

<br>

### 요약
GCD는 iOS에서 멀티스레딩과 비동기 작업 관리를 위해 설계된 API로, 앱의 성능을 최적화하고 사용자 경험을 개선하는 역할을 합니다. GCD는 큐와 QoS를 통해 작업을 효율적으로 배분하며, 메인 스레드에서의 UI 업데이트도 안전하게 관리할 수 있도록 지원합니다.

  
<br>
<br>

## 7. 메모리 관리 기법 중 iOS에서 사용되는 방식과 그 특징에 대해 설명해주세요.

<img src="https://github.com/user-attachments/assets/3ff2fe33-2b2c-4987-8050-8b41de72cffc">

iOS에서는 **ARC (Automatic Reference Counting)** 라는 메모리 관리 기법을 사용합니다. ARC는 앱이 사용하는 메모리를 효율적으로 관리하기 위해 객체의 참조 카운트를 자동으로 조정하여, 더 이상 필요하지 않은 객체를 메모리에서 해제합니다. 다음은 iOS의 ARC 메모리 관리 기법과 그 특징입니다.

<br>

### Automatic Reference Counting (ARC)
ARC는 Swift와 Objective-C에서 사용하는 자동 메모리 관리 시스템입니다. 각 객체에 대해 **참조 횟수(Reference Count)** 를 추적하며, 참조가 0이 되면 객체를 메모리에서 해제합니다.


<br>

#### 주요 특징:
- 자동관리 :
  - ARC는 컴파일러 수준에서 자동으로 관리되므로, 개발자가 명시적으로 메모리를 할당하거나 해제할 필요가 없음
- 참조 카운트 기반 :
  - 객체가 생성될 때마다 참조 카운트가 증가하고, 더 이상 참조되지 않으면 카운트가 감소.
  - 카운트가 0이 되면 메모리가 해제
- 성능 최적화 :
  - 수동으로 메모리를 관리하는 것보다 오류 발생 가능성이 낮으며, 대부분의 경우 성능 면에서도 최적화되어 있음
 
<br>

#### 참조 타입의 종류와 순환 참조 해결:
iOS에서는 ARC의 특성을 활용해 참조 타입의 종류를 다르게 사용함으로써 **순환 참조(Circular Reference)** 를 방지합니다. 순환 참조는 두 객체가 서로를 강한 참조로 가지게 되어, 참조 카운트가 0이 되지 않아 메모리에서 해제되지 않는 문제입니다. 이를 방지하기 위해 다음의 참조 타입이 사용됩니다.

<br>

- 강한 참조(Strong Reference) :
  - 기본적인 참조 방식으로, 참조하는 객체의 카운트를 증가
  - 두 객체가 서로 강한 참조를 가지면 순환 참조 문제가 발생할 수 있음

```swift
class Person {
    var pet: Pet?  // 기본적으로 강한 참조
    deinit { print("Person is being deinitialized") }
}

class Pet {
    var owner: Person?  // 기본적으로 강한 참조
    deinit { print("Pet is being deinitialized") }
}

// 사용 예시
var person: Person? = Person()
var pet: Pet? = Pet()

person?.pet = pet  // Person이 Pet을 강하게 참조
pet?.owner = person // Pet이 Person을 강하게 참조

person = nil       // 순환 참조로 인해 deinit 호출되지 않음
pet = nil          // 순환 참조로 인해 deinit 호출되지 않음

```

<br>

- 약한 참조(Weak Reference) :
  - 참조는 하되 참조 카운트를 증가시키지 않는 방식
  - weak 키워드로 선언하며, 참조 대상 객체가 메모리에서 해제되면 nil이 됨
  - 주로 delegate 패턴에서 사용
 
```swift
class Person {
    var pet: Pet?
    deinit { print("Person is being deinitialized") }
}

class Pet {
    weak var owner: Person?  // 약한 참조
    deinit { print("Pet is being deinitialized") }
}

// 사용 예시
var person: Person? = Person()
var pet: Pet? = Pet()

person?.pet = pet         // Person이 Pet을 강하게 참조
pet?.owner = person       // Pet이 Person을 약하게 참조

person = nil              // Person이 해제되고, 약한 참조로 순환 참조가 발생하지 않음
// 출력: "Person is being deinitialized"
pet = nil                 // Pet도 해제됨
// 출력: "Pet is being deinitialized"
```

<br>

- 비소유 참조(Unmanaged Reference) :
  - unowned 키워드를 사용하여 참조 카운트를 증가시키지 않지만, 참조 대상이 해제되더라도 nil이 됨
  - 참조 대상이 해제되기 전에만 사용해야 함
  - 주로 강한 순환 참조를 방지하는 데 사용됨


```swift
class Customer {
    var creditCard: CreditCard?
    deinit { print("Customer is being deinitialized") }
}

class CreditCard {
    unowned let customer: Customer  // 비소유 참조
    init(customer: Customer) {
        self.customer = customer
    }
    deinit { print("CreditCard is being deinitialized") }
}

// 사용 예시
var customer: Customer? = Customer()
customer?.creditCard = CreditCard(customer: customer!)

customer = nil  // CreditCard도 해제됨
// 출력: "Customer is being deinitialized"
// 출력: "CreditCard is being deinitialized"

```


<br>

#### ARC와 메모리 관리의 주요 특징
- 컴파일 타임에 관리:
  - ARC는 런타임이 아니라 컴파일 타임에 코드에 삽입되므로, 자동 메모리 관리가 매우 효율적으로 작동
- 메모리 누수 방지:
  - 강한 순환 참조를 피하고 약한 참조와 비소유 참조를 적절히 사용하여 메모리 누수를 방지
- 비동기 코드에서 주의:
  - 클로저 내부에서 self를 강하게 캡처하면 메모리 누수가 발생
  - 이를 방지하기 위해 [weak self]를 사용해 약하게 캡처
 
<br>

#### ARC가 관리하지 않는 메모리
ARC는 객체 인스턴스에 대해서만 메모리를 관리

<br>

- C언어 스타일의 메모리 할당 :
  - malloc이나 free와 같은 C 언어의 메모리 관리 방식은 ARC에서 관리되지 않음
- Core Graphics 객체 :
  - CGContext, CGColor 등 Core Graphics에서 사용하는 객체는 ARC의 대상이 아니며, 수동으로 해제해야함
- Unmanaged 객체 :
  - Swift와 Objective-C 간의 브릿징을 통해 생성된 Unmanaged 객체도 ARC의 관리 대상이 아님
 
<br>

#### 메모리 관리 관련 키워드
- weak과 unowned는 ARC에서 순환 참조를 방지하기 위해 사용됩니다.
- @autoreleasepool:
  - iOS에서는 큰 메모리 작업이나 비동기 작업에서 메모리 사용량을 줄이기 위해 @autoreleasepool 블록을 사용하여 자동 해제를 조절할 수 있습니다.

<br>

### 요약
iOS의 메모리 관리 기법인 ARC는 객체의 참조 카운트를 기반으로 자동 메모리 해제를 수행하여, 개발자가 직접 메모리 해제를 관리하지 않아도 되도록 돕습니다. 강한 참조, 약한 참조, 비소유 참조 등을 적절히 사용하여 순환 참조 문제를 해결하며, ARC가 관리하지 않는 요소에 대해 추가적인 메모리 관리도 필요할 수 있습니다.




<br>
<br>

## 7.1 자동 참조 카운팅(ARC)은 어떻게 동작하나요?
- ARC는 iOS와 macOS에서 메모리를 자동으로 관리하는 시스템
- 객체가 생성될 때마다 참조 카운트가 증가
- 더 이상 참조되지 않으면 참조 카운트가 0으로 줄어들고, 메모리에서 자동으로 해제됨
- ARC는 컴파일러 수준에서 자동으로 관리되므로, 개발자가 명시적으로 메모리를 할당하거나 해제할 필요가 없음

<br>
<br>

## 7.2 Garbage Collection과의 차이는 무엇인가요?

<img src="https://github.com/user-attachments/assets/4dce7650-e7b2-4df6-8b3f-779c74317253">

### 결론
ARC와 GC 모두 자동 메모리 관리 방식을 제공하지만, ARC는 참조 카운트 기반이고 컴파일 타임에 관리되는 반면, GC는 주기적으로 메모리를 스캔하여 관리합니다. ARC는 보다 일관된 성능을 제공하지만 순환 참조에 주의해야 하며, GC는 개발자가 메모리 관리에 덜 신경 쓰도록 도와주지만 성능에 일시적인 영향을 미칠 수 있습니다.

<br>

> - 컴파일 타임 시점 :
>   - 코드를 작성한 후 빌드를 돌릴 때 발생하며, 코드를 기계어로 변환하고 에러 검사를 하는 시점입니다.
> - 런타임 시점 : 
>   - 앱이 실제로 기기에서 실행되는 시점으로, 사용자의 인터랙션에 따라 동작하며, 앱이 종료될 때까지 유지됩니다.

<br>
<br>

## 8. iOS의 샌드박스(Sandbox) 개념과 역할, 그리고 앱 간 데이터 공유 방법에 대해 설명해주세요.
**iOS의 샌드박스(Sandbox)** 는 각 앱이 독립된 환경에서 실행되도록 격리하는 보안 구조입니다. 이는 앱이 시스템 리소스나 다른 앱의 데이터에 무분별하게 접근하지 못하도록 막아주는 역할을 합니다. 이로 인해 iOS는 높은 수준의 보안을 유지할 수 있으며, 사용자의 데이터를 보호할 수 있습니다.

### 샌드박스(Sandbox) 개념과 역할
- 개념 :
  - iOS에서 샌드박스는 각 앱에 고유한 디렉토리 구조와 권한을 부여하여 외부로부터 격리된 환경에서 실행되도록 하는 보안 구조
- 역할 :
  - 데이터 보호 :
    - 각 앱의 데이터는 다른 앱에서 접근할 수 없으므로, 사용자의 개인 정보와 파일이 보호
  - 시스템 보호 :
    - 앱이 시스템 리소스나 운영체제의 중요한 부분에 직접 접근하지 못하게 하여, 앱의 오류나 악성 코드가 시스템에 영향을 미치지 않도록 함
  - 안정성 유지 :
    - 앱이 오류로 인해 강제 종료되더라도 다른 앱이나 시스템에 영향을 미치지 않으므로 iOS의 안정성을 높임

<br>

### 샌드박스에서의 앱 파일 구조
각 앱은 iOS에서 고유의 디렉토리를 할당받으며, 일반적으로 다음과 같은 구조를 가지고 있습니다:

#### Documents :
- 앱의 주요 데이터가 저장되는 폴더로, 사용자가 생성한 파일이나 데이터가 저장
  
#### Library :
- 캐시 및 설정 파일이 저장되는 폴더
  - Caches : 임시 데이터를 저장하는 데 사용되며, 시스템에 의해 삭제될 수 있음
  - Preferences : 설정 파일이 저장되는 폴더로, UserDefaults 데이터가 저장

#### tmp :
- 임시 파일을 저장하는 폴더로, 앱이 종료되면 삭제될 수 있음


<br>
<br>

## 8.1 URL 스킴(URL Scheme)을 이용한 앱 간 통신은 어떻게 이루어지나요?



<br>
<br>

## 8.2 앱 그룹(App Group)을 활용하여 데이터 공유를 하는 방법은 무엇인가요?


  
<br>
<br>

## 9. **iOS에서의 메모리 구조와 관리 방식에 대해 자세히 설명해주세요.**
    - 힙(Heap)과 스택(Stack)의 차이점은 무엇인가요?
  
<br>
<br>

## 10. **네트워크 프로토콜 스택과 iOS에서의 네트워크 통신 방식에 대해 설명해주세요.**

<br>
<br>

## 11. **HTTP와 HTTPS의 차이점, 그리고 iOS에서의 보안 통신 방법에 대해 설명해주세요.**
    - SSL/TLS의 동작 원리는 무엇인가요?
<br>
<br>

## 12. **컴퓨터 네트워킹에서 OSI 7계층 모델에 대해 설명해주세요.**
    - 각 계층의 역할과 프로토콜은 무엇인가요?
    - TCP/IP 모델과 OSI 모델의 차이점은 무엇인가요?
<br>
<br>

## 13. **HTTP 프로토콜의 특징과 HTTP/1.1과 HTTP/2의 차이점을 설명해주세요.**
    - HTTP의 무상태(Stateless) 성질은 무엇이며, 어떻게 극복하나요?
    - HTTP/2에서 추가된 주요 기능은 무엇인가요?
    - HTTP/3에서 추가된 기능은 무엇인가요?

<br>
<br>

## 14. **TCP와 UDP의 특징과 차이점에 대해 설명해주세요.**
    - 연결 지향형 프로토콜과 비연결 지향형 프로토콜은 무엇인가요?
    - TCP의 3-way handshake 과정은 어떻게 이루어지나요?
    - 어떤 상황에서 UDP를 사용하는 것이 적합한가요?

<br>
<br>

## 15. **소켓 통신에 대해 설명해주세요.**

<br>
<br>

## 16. **REST API와 iOS에서의 네트워크 요청 및 응답 처리 방법에 대해 설명해주세요.**
    - iOS에서 `URLSession`을 사용하여 네트워크 요청을 보내는 방법은 무엇인가요?

<br>
<br>

## 17. **REST API에서 HTTP 메서드들의 차이점을 설명해주세요.**
    - `GET`과 `POST`의 차이점은 무엇인가요?

<br>
<br>

## 18. **HTTP 상태 코드에 대해서 설명해주세요.**

<br>
<br>

## 19. **iOS에서 이미지 파일 포맷(PNG, JPEG 등)과 각 포맷의 특징에 대해 설명해주세요.**
    - PNG와 JPEG의 차이점은 무엇인가요?
   
<br>
<br>

## 20. **PNG 파일이 어떻게 저장되고 구성되는지 설명해주세요.**

<br>
<br>

## 21. **iOS에서 메모리 사이즈와 관련된 개념과 고려 사항에 대해 설명해주세요.**
    - 메모리 정렬(Alignment)이 성능에 미치는 영향은 무엇인가요?
   
<br>
<br>

## 22. **iOS 디바이스의 메모리 제약과 앱 메모리 제한에 대해 설명해주세요.**
    - 메모리 경고(Memory Warning)가 발생하면 어떤 조치를 취해야 하나요?
   
<br>
<br>

## 23. **알고리즘의 시간 복잡도와 공간 복잡도의 개념, 그리고 빅오 표기법에 대해 설명해주세요.**
    - O(n)과 O(log n)의 차이는 무엇인가요?
   
<br>
<br>

## 24. **자주 사용되는 정렬 알고리즘(예: 퀵 정렬, 병합 정렬)의 동작 원리와 시간 복잡도를 설명해주세요.**

<br>
<br>

## 25. **이진 탐색의 원리와 시간 복잡도에 대해 설명해주세요.**

<br>
<br>

## 26. **동적 프로그래밍(Dynamic Programming)의 개념을 설명해주세요.**

<br>
<br>

## 27. **자료구조의 종류와 iOS 개발에서 자주 사용되는 자료구조에 대해 설명해주세요.**

<br>
<br>

## 28. **배열, 연결 리스트, 스택, 큐의 특징과 iOS에서의 구현 방법을 설명해주세요.**

<br>
<br>

## 29. **해시 테이블의 개념과 충돌 해결 방법을 설명해주세요.**

<br>
<br>

## 30. **암호화와 보안의 기본 개념, 그리고 iOS 앱 보안을 위한 방안에 대해 설명해주세요.**

<br>
<br>

## 31. **가상 메모리(Virtual Memory)의 개념과 동작 원리에 대해 설명해주세요.**

<br>
<br>


## 32. **데이터베이스의 종류와 iOS에서 주로 사용되는 데이터베이스에 대해 설명해주세요.**

<br>
<br>


## 33. **싱글톤 패턴(Singleton Pattern)이란 무엇이며, 어떤 경우에 사용하나요?**

<br>
<br>


## 34. **Swift에서 싱글톤 패턴을 구현할 때 멀티스레드에 대해서 어떻게 고려해야 하나요?**


<br>
<br>
