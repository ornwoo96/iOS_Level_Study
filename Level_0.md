

# Level 0

## 1. 컴퓨터 시스템에서 CPU, RAM, 저장 장치의 역할과 이들이 어떻게 상호 작용하는지 설명해주세요.

<img src="https://github.com/user-attachments/assets/b7748bfe-fdb5-4655-b153-f15388fdff0e">

### CPU (Central Processing Unit)
**역할 :**
- 컴퓨터의 중앙 처리 장치. 컴퓨터의 두뇌

**특징 :**
- 시스템의 명령어를 해석하고 실행
- 모든 연산과 논리 처리 담당
- 직렬(순차)처리 방식에 특화된 구조
- CPU는 연산장치(ALU) / 제어 장치(Control Unit) / 레지스터 로 구성

**장치 설명 :**
- 연산장치(ALU) :
  - 산술 및 논리 연산을 수행. 예) 덧셈, 뺄셈, 곱셈, 나눗셈 등
- 제어 장치 :
  - 프로그램 명령어를 해석
  - 명령어의 실행 순서를 제어
- 레지스터 :
  - CPU 내부의 매우 빠른 메모리
  - 현재 처리 중인 데이터와 주소를 임시 저장
 
**상호 작용 :**
- CPU는 시스템 버스를 통해 RAM과 저장장치와 연결
- 데이터와 명령어를 RAM에서 가져와 처리하고, 필요시 결과를 저장장치에 저장

<br>

<img src="https://github.com/user-attachments/assets/a009896e-e2d9-4643-a047-71c57062d41c">

### RAM (Random Access Memory)
**역할 :**
- 컴퓨터의 주기억 장치

**특징 :**
- 휘발성 메모리
- 데이터 임시 저장 :
  - 프로그램 실행 중 필요한 데이터와 명령어를 일시적으로 저장 
  - 프로그램이 실행 될때 :
    - 프로그램의 데이터와 명령어는 하드 디스크에서 RAM 으로 로드되어 CPU에 의해 처리
  - 프로그램과 데이터를 저장하는 용도로는 적합하지 않음
- 빠른 접근 속도 :
  - CPU가 빠르게 접근할 수 있도록 자주 사용되는 데이터와 명령어를 저장하는 데 적합
  - RAM은 HDD 나 SSD 보다 훨씬 빠른 속도로 데이터에 접근 가능 -> CPU와의 데이터 교환에 적합
 
**상호 작용 :**
- CPU는 RAM에 있는 데이터를 읽고 쓰며, RAM은 프로그램 실행 중 필요한 데이터를 빠르게 제공하여 CPU의 성능을 최적화
- RAM의 내용은 전원이 꺼지면 사라짐

<br>

<img src="https://github.com/user-attachments/assets/dcf454c0-050e-4217-b401-ecfbce371281">


### 저장 장치 (HDD-하드 디스크 드라이브 / SSD-솔리드 스테이트 드라이브)
**역할 :**
- 데이터와 프로그램의 영구적 저장

**특징 :**
- 비휘발성 메모리
- 데이터 영구 저장 :
  - 운영 체제, 애플리케이션, 사용자 파일 등을 영구적 저장
  - 전원이 꺼져도 데이터 유지
- 느린 접근 속도 :
  - HDD는 물리적 디스크를 회전시켜 데이터를 읽고 쓰는 방식 
  - SSD는 반도체를 사용하여 HDD보다 빠름
  - 그러나 둘다 RAM에 비해 느림

**상호 작용 :**
- CPU와 RAM의 데이터를 영구적으로 저장하거나 필요할 때 불러오는 역할을 합니다.
- 운영체제, 애플리케이션, 사용자 데이터 등이 저장됩니다.

<br>
<br>

## 1.1 CPU와 메모리 간의 데이터 교환은 어떻게 이루어지나요?


<img src="https://github.com/user-attachments/assets/88dec934-898e-4e0c-845c-8194a5d49710">

CPU와 메모리 간의 데이터 교환은 **버스(Bus)** 라는 통로를 통해 이루어집니다.

<br>

**단계 :**
1. 주소 지정(Addressing)
- CPU는 데이터 또는 명령어가 저장된 메모리의 특정 위치에 접근해야 합니다.
- 이를 위해 **주소 버스(Address Bus)** 를 통해 메모리 주소를 전송하여 필요한 데이터의 위치를 지정합니다.
<br>

2. 명령어 및 데이터 페치(Fetch)
- CPU는 메모리에 있는 명령어 또는 데이터를 가져오기 위해 **데이터 버스(Data Bus)** 를 사용합니다.
- CPU가 필요한 데이터가 메모리에서 RAM으로 전송되며, CPU는 이를 가져와 연산을 준비합니다.
<br>

3. 연산(Execute)
- 데이터를 메모리에서 가져오면, CPU는 연산을 수행합니다.
- 연산은 CPU의 **연산 장치(ALU)** 에서 이루어지며, 산술 연산 또는 논리 연산을 처리하게 됩니다.
<br>

4. 저장(Store)
- 연산 결과가 나오면, CPU는 이 결과를 다시 메모리에 저장할 수 있습니다.
- 이를 위해 데이터 버스를 통해 데이터를 메모리의 특정 주소로 전송하며, 이 주소 정보는 주소 버스를 통해 전달됩니다.
<br>

5. 제어(Control)
- 이 모든 데이터 교환 과정은 **제어 버스(Control Bus)** 를 통해 관리됩니다.
- 제어 버스는 CPU가 메모리와의 데이터 전송을 동기화하고 제어 신호를 보내는 역할을 합니다.
- 예를 들어, 읽기/쓰기 신호나 인터럽트 신호를 통해 데이터 교환의 타이밍과 순서를 조정합니다.


<br>

**요약 :**
- 버스 시스템을 통해 CPU와 메모리는 효율적으로 데이터를 주고 받으며 컴퓨터의 다양한 작업을 수행할 수 있음
- CPU와 메모리 간의 데이터 교환은 주소 버스, 데이터 버스, 제어 버스를 통해 이루어짐
- 주소 지정 -> 데이터/명령어 페치 -> 연산 -> 저장 |<< 과정을 반복하여 프로그램을 실행

<br>
<br>

## 1.2 버스(Bus)란 무엇이며, 어떤 종류가 있나요?

**컴퓨터 내부에서 데이터를 전달하는 통로** 로, CPU, 메모리, 저장 장치, 입출력 장치 간의 데이터 교환을 가능하게 함
다양한 구성 요소가 데이터를 주고 받는 통신 경로를 제공
주소, 데이터, 제어 신호를 포함한 여러 정보를 전송할 수 있음

<br>

### 버스의 종류
#### 1. 주소 버스 (Address Bus)
#### 역할 :
- CPU가 메모리 또는 다른 장치에 접근할 때, 접근하고자 하는 위치(주소)를 전달

#### 특징 :
- 주소 버스는 단방향으로 작동하여 CPU에서 메모리나 장치로 주소 정보를 전송
- 버스의 폭은(비트 수)은 CPU가 접근할 수 있는 메모리 용량을 결정
- 예) 32비트 주소 버스는 최대 4GB의 메모리 공간을 주소 지정 가능

<br>

#### 2. 데이터 버스 (Data Bus)
#### 역할 :
- CPU와 메모리 또는 다른 장치 간의 데이터 전송을 담당

<br>

#### 특징 :
- 데이터 버스는 양방향으로 작동하여 CPU와 메모리간, 또는 CPU와 장치 간의 데이터를 주고 받을 수 있음
- 데이터 버스의 폭(비트 수)은 한 번에 전송할 수 있는 데이터의 크기를 결정
- 버스 폭이 넓을 수 록 데이터를 더 많이, 더 빠르게 전송할 수 있음

<br>

#### 3. 제어 버스
#### 역할 :
- 제어 신호를 전달하여 각 장치의 동작을 관리
- 데이터 전송의 타이밍과 방향을 조정

<br>

#### 특징 :
- 제어 버스는 읽기/쓰기 신호, 인터럽트 요청, 클럭 신호 등을 포함
- CPU와 메모리, 주변 장치 간의 동작을 동기화 하는 역할
- CPU가 데이터를 읽거나 쓰는 작업을 제대로 수행할 수 있도록 지원

<br>

> #### 인터럽트 요청:
> - CPU가 중요한 외부 요청(예: 입력, 네트워크 신호 등)을 빠르게 처리할 수 있도록 하는 신호.
> #### 클럭 신호:
> - CPU와 시스템의 모든 구성 요소가 동기화된 속도로 동작하도록 조절하는 신호로, CPU의 성능과 속도를 결정합니다.

<br>

### 요약 :
- 주소 버스: 데이터 위치(주소)를 지정하기 위해 사용되는 단방향 버스
- 데이터 버스: CPU와 메모리, 주변 장치 간의 실제 데이터를 전송하는 양방향 버스
- 제어 버스: 동작을 관리하고 신호를 통해 각 장치의 통신을 제어하는 버스


<br>
<br>



## 2. **캐시 메모리의 개념과 역할에 대해 설명해주세요.**

<img src = "https://github.com/user-attachments/assets/f68cfaff-5269-419b-8a83-743325806ea1">

#### 개념 :
캐시 메모리는 CPU와 메인 메모리(RAM) 사이에 위치한 고속의 소형 메모리로, 자주 사용하는 데이터나 명령어를 임시로 저장하여 CPU의 처리속도를 높이는 역할을 함. 캐시는 CPU가 자주 접근하는 데이터를 빠르게 제공하여, CPU가 메인 메모리의 느린 접근 속도로 인해 발생하는 지연 시간을 줄이는 데 중요한 역할을 함
- 고속 메모리 :
  - 캐시 메모리는 RAM 보다 훨씬 빠르지만, 용량이 작음
  - CPU와 가까운 위치에 있어 데이터 전송 속도가 빠름
- 임시 저장소 :
  - 자주 사용되거나 가까운 시일 내에 다시 필요할 것으로 예상되는 데이터를 일시적으로 저장
  - 캐시는 데이터를 RAM에 저장하는 대신 빠르게 CPU에 전달합니다.
- 계층 구조 :
  - 캐시는 보통 여러 계층 (L1, L2, L3)으로 구성
  - L1 :
    -  CPU 내부에 내장되어 있으며 가장 빠르고 용량이 적음
  - L2, L3 :
    - 용량이 그보다 크고 조금 더 느린 캐시
   
<br>

#### 역할 :
캐시 메모리는 CPU의 성능 향상을 위해 다음과 같은 역할을 함
- 데이터 접근 속도 향상 :
  - 캐시 메모리는 이러한 데이터를 CPU에 가까이 위치시켜, 자주 사용하는 데이터에 대한 접근 시간을 줄임
- 메모리 병목 현상 완화 :
  - 메인 메모리(RAM)보다 빠르게 접근할 수 있어, CPU가 메모리 속도에 구애받지 않고 연속적으로 작업을 수행할 수 있게함
  - 이를 통해 CPU가 메모리 병목 없이 데이터 처리할 수 있게 도움
- 전력 소비 절감 :
  - CPU가 RAM 대신 캐시에서 데이터를 빠르게 가져오면, 메모리에 접근할 때보다 전력을 덜 소모할 수 있어 시스템의 에너지 효율이 높아짐
 
<br>

#### 캐시 히트(Cache Hit)와 캐시 미스(Cache Miss)

- 캐시 히트(Cache Hit):
  - CPU가 요청한 데이터가 캐시에 존재하여, RAM에 접근하지 않고 바로 CPU로 전달되는 경우를 말합니다.
  - 캐시 히트가 발생하면 데이터 접근 속도가 빨라집니다.
- 캐시 미스(Cache Miss):
  - CPU가 요청한 데이터가 캐시에 없는 경우로, 이때는 메인 메모리(RAM)에서 데이터를 가져와 캐시에 저장하고, CPU에 전달해야 합니다.
  - 캐시 미스가 발생하면 데이터 접근 속도가 느려집니다.


<br>
<br>

## 2.1 캐시의 지역성(Locality) 원리에 대해 설명해주세요.
**캐시의 지역성(Locality) 원리** 는 컴퓨터 시스템에서 데이터를 접근할 때, 특정 패턴을 활용하여 데이터 접근 속도를 향샹시키는 원리입니다.
캐시 메모리는 이 지역성 원리를 기반으로 작동하며, 자주 또는 연속적으로 사용하는 데이터를 미리 캐시에 저장해 CPU의 데이터 접근 시간을 줄입니다. 지역성 원리는 크게 두가지, **시간적 지역성 / 공간적 지역성** 으로 나뉩니다.

<br>

#### 시간적 지역성 (Temporal Locality) :
시간적 지역성은 **최근에 사용된 데이터가 가까운 시간 내에 다시 사용될 가능성이 높다** 는 원리 입니다.
예를 들어, 루프(loop)나 함수에서 사용되는 변수나 데이터는 반복적으로 접근되기 때문에 시간적 지역성을 따릅니다.
- 예시 :
  - 프로그램이 특정 변수를 한 번 사용한 후, 이후에 여러 번 더 참조할 경우, 이 변수는 시간적 지역성을 가진다.
- 캐시 활용 :
  - 캐시는 최근에 사용한 데이터를 저장하여, 동일한 데이터에 다시 접근할 때 캐시에서 빠르게 가져올 수 있도록 합니다.
  - 이로 인해 RAM 접근을 줄일 수 있어 효율이 높아짐
 
<br>

#### 공간적 지역성 (Spatial Locality)
공간적 지역성은 **특정 메모리 위치에 접근할 때, 그 위치와 인접한 메모리 위치도 곧 접근할 가능성이 높다** 는 원리 입니다. 프로그램에서 배열이나 연속된 메모리 블록을 사용하는 경우 공간적 지역성이 발생합니다.
- 예시 :
  - 배열을 순차적으로 탐색하거나, 코드가 연속적인 메모리 위치에 있는 명령어를 순서대로 실행할 경우, 해당 데이터들은 공간적 지역성을 갖음
- 캐시 활용 :
  - 캐시는 데이터나 명령어를 가져올 때 인접한 메모리 블록을 함께 가져와 저장합니다.
  - 이를 통해, 인접 데이터에 접근할 때도 빠르게 데이터를 제공할 수 있어 성능이 향상
 
<br>

#### 지역성 원리가 캐시에 미치는 영향
캐시 메모리는 지역성 원리에 따라 데이터를 캐시에 저장하고 관리합니다. 데이터 접근 패턴이 시간적 및 공간적 지역성을 잘 따를수록 캐시 히트(Cache Hit)율이 높아지며, CPU는 데이터 접근 시간을 줄이고 성능을 극대화할 수 있습니다. 반면, 데이터 접근 패턴이 지역성을 따르지 않을 경우 캐시 미스(Cache Miss)율이 높아져 캐시의 성능이 떨어질 수 있습니다.

<br>

#### 요약
- 시간적 지역성 : 최근 사용된 데이터가 다시 사용될 가능성이 높음
- 공간적 지역성 : 특정 위치의 데이터에 접근할 때 인접 데이터도 함께 접근할 가능성이 높음


<br>
<br>



## 3. CPU 아키텍처의 종류(예: ARM, x86)와 각 특징에 대해 설명해주세요.

CPU 아키텍처는 CPU가 데이터를 처리하고 명령어를 실행하는 방식과 구조를 정의합니다.

<br>


<img src="https://github.com/user-attachments/assets/70fa0118-4d9c-4978-b46c-ccd66ebc7ed5">

### x86 아키텍처
**x86** 아키텍처는 **인텔** 이 개발한 아키텍처로, 주로 데스크탑과 서버에 사용됩니다.
이 아키텍처는 **복잡한 명령어 집합 컴퓨터(CISC, Complex Instruction Set Computing)** 구조를 따르며, 다양한 명령어와 기능을 포함하고 있습니다.

<br>

#### 특징 :
- CISC 구조 :
  - x86 아키텍처는 복잡한 명령어 집합을 제공, 한 명령어가 여러 단계를 처리 가능
- 고성능 :
  - 복잡한 명령어와 높은 처리 성능 덕분에, 데스크톱, 서버, 워크스테이션 등 고성능이 요구되는 환경에 적합
- 높은 전력 소비 :
  - 많은 명령어와 복잡한 회로 구조로 인해 전력 소비가 높아 모바일 기기보다는 주로 데스크톱과 서버 환경에서 사용
- 소트프웨어 호환성 :
  - x86은 오래전부터 널리 사용되어 왔기 때문에, Windows와 linux 같은 다양한 운영체제와 소프트웨어에서 폭 넓게 지원

<br>

#### 대표 프로세서:
- Intel Core 시리즈
- AMD Ryzen 시리즈

<br>


<img src="https://github.com/user-attachments/assets/cf945b92-a279-4cb0-8a68-c34da1b9b829">


### ARM 아키텍처
**ARM** 아키텍처는 **Advanced RISC Machine** 의 약자로, 모바일 기기와 같은 저전력 환경을 위한 **간단한 명령어 집합 컴퓨터(RISC, Reduced Instruction Set Computing)** 구조를 따릅니다. ARM은 간단한 명령어를 빠르게 처리할 수 있어 전력 효율이 높습니다.

<br>

#### 특징 :
- RISC 구조 :
  - ARM 아키텍처는 명령어 집합이 간단하고, 한 번에 하나의 연산을 수행하는 명령어 구조를 가지고 있어 전력 소모가 적음
  - 배터리 성능이 중요한 모바일 기기에서 매우 유리
- 저전력 :
  - 간단한 명령어 집합과 효율적인 설계 덕분에 전력 소비가 적어 스마트폰, 태블릿, IoT 장치 등에 널리 사용
- 고성능화 :
  - 최근에는 성능이 개선되어 데스크톱과 서버에서도 사용할 수 있게 되었음
  - Apple의 M 칩 시리즈가 ARM 아키텍처를 기반으로 하며, 각 애플 기기에 우수한 성능을 보임
 
<br>

#### 요약
- x86 :
  - 복잡한 명령어 집합을 사용하여 고성능을 제공하며, 데스크톱과 서버에 적합
- ARM :
  - 간단한 명령어 집합으로 저전력 소모와 효율을 강조하며, 모바일 기기 및 배터리 가반 기기에 유리

<br>
<br>

## 4. iOS 기기에서 사용되는 AP(Application Processor)의 특징과 역할에 대해 설명해주세요.
애플의 모바일 및 태블릿 장치에서 **중앙 처리 장치 역할을 담당하는 칩 (CPU)** 으로, 애플 실리콘 실리즈가 대표적입니다.

### AP의 주요 특징
- ARM 기반 설계 :
  - 애플 AP는 ARM 아키텍처를 기반으로 하여 고성능과 저전력을 지원
- Big.LITTLE 구조 :
  - 고성능 코어와 저전력 코어를 조합하여 성능과 배터리 효율을 최적화
- 뉴럴 엔진(Neural Engine) :
  - AI와 머신러닝 작업을 빠르게 처리해 얼굴 인식, 사진 및 비디오 처리, 자연어 처리 등에서 높은 성능을 제공
- 통합 메모리 아키텍처 (Unified Memory Architecture) :
  - CPU, GPU, 뉴럴 엔진이 메모리를 공유하여 데이터 접근 속도가 빠르고 효율적
- 고급 제조 공정 :
  - 5nm, 3nm 공정을 적용해 트랜지스터 밀도가 높고 전력 효율이 뛰어남

<br>

### AP의 역할
- 중앙 처리 :
  - 앱 실행 / 데이터 연산 / UI 반응을 포함한 기기 내 모든 연산을 처리
- 그래픽 처리 :
  - 내장된 GPU를 통해 고화질 영상과 고사양 게임을 부드럽게 구현
  - Metal API를 통해 성능 극대화
- AI와 머신러닝 :
  - 뉴럴 엔진으로 AI 작업을 신속히 처리
  - 사진 편집 / AR / 얼굴 인식 등에 활용
- 저전력 관리 :
  - 고성능을 유지하면서도 배터리 수명을 최적화하여 장시간 사용을 지원


<br>
<br>

## 4.1 SoC(System on a Chip)의 개념은 무엇인가요?

<img src="https://github.com/user-attachments/assets/348c5ce2-450f-43c7-93a5-7506ba239342">


**SoC(System on a Chip)** 는 하나의 칩에 CPU, GPU, 메모리, 뉴럴 엔진, 입출력 장치 등 다양한 시스템 구성 요소를 통합한 반도체를 말합니다.

### SoC의 주요 개념
- 통합 설계 :
  - SoC는 CPU, GPU, 메모리 컨트롤러, AI 연산용 뉴럴 엔진, 이미지 신호 프로세서(ISP)와 같은 다양한 장치를 단일 칩에 포함하여, 전체 시스템의 성능과 효율성을 높입니다.
- 크기 및 전력 효율 :
  -  여러 기능을 하나에 칩에 통합함으로써 부품 크기와 전력 소모를 줄일 수 있어, 스마트폰, 태블릿과 같은 모바일 기기에 특히 적합
- 다양한 기능 :
  - SoC는 단일 칩에서 컴퓨팅, 그래픽 처리, 신호 처리 등 다양한 작업을 수행하여 별도의 칩이 필요 없는 완전한 컴퓨팅 솔루션을 제공

<br>

### SoC의 예시
애플의 A 시리즈 칩 (iPhone, Apple TV)과 M 1,2,3,4 시리즈 칩(Mac, iPad)은 SoC의 대표적인 예로 CPU, GPU, 뉴럴 엔진, 메모리 등이 단일 칩에 통합되어 있어 강력한 성능과 효율성을 갖추고 있습니다. (현재 작성자도 M3 Pro Chip 사용중..😎)



<br>
<br>

## 5. 운영체제의 역할과 iOS의 운영체제 구조에 대해 설명해주세요.
**운영 체제(OS)** 는 컴퓨터 하드웨어와 소프트웨어를 관리하고, 사용자와 시스템 간의 상호작용을 가능하게 하는 소프트웨어입니다. **운영체제의 주요 역할** 과 **iOS의 운영체제 구조** 는 다음과 같습니다.

### 운영체제의 주요 역할
- 하드웨어 관리 :
  - CPU, 메모리, 저장 장치, 입출력 장치 등 하드웨어 자원을 효율적으로 관리
- 프로세스 관리 :
  - 여러 어플리케이션이 동시에 실행될 수 있도록 프로세스를 관리
  - CPU 스케줄링과 메모리 할당 조정
- 메모리 관리 :
  - 각 프로그램이 필요한 메모리를 할당받고 해제하도록 조정하여 메모리 효율성 유지
- 파일 시스템 관리 :
  - 파일 저장, 읽기, 쓰기를 관리하며, 데이터의 무결성과 보안을 유지
- 사용자 인터페이스 제공 :
  - 사용자가 기기와 상호작용할 수 있도록 명령어 인터페이스(CLI)나 그래픽 사용자 인터페이스(GUI)를 제공
- 보안과 접근 제어 :
  - 사용자 인증 및 접근 권한을 제어해 시스템을 보호
  - 데이터를 안전하게 관리
 
<br>

### iOS의 운영체제 구조
iOS는 Apple의 모바일 운영체제로, 효율성과 보안을 유지하면서도 다양한 애플리케이션과 기능을 지원하기 위해 계층 구조로 설계되었습니다. iOS의 주요 계층은 다음과 같습니다.

<br>

#### 코어 OS(Core OS) 
- 하드웨어와 가장 밀접하게 연관된 계층으로, iOS 장치의 전력 관리, 파일 시스템, 보안, 네트워크 기능을 제어
- iOS에서 가상 메모리, 파일 시스템 및 저장 장치 관리와 같은 기본적인 시스템 서비스를 제공
- 다양한 하드웨어와 소프트웨어 간의 안정성과 성능을 보장하기 위해 가장 낮은 수준의 기능을 담당

<br>

#### 코어 서비스(Core Services) 
- 애플리케이션이 기기의 기본 기능에 접근할 수 있도록 하는 다양한 프레임워크와 라이브러리를 포함
- 예를 들어, Core Data는 데이터 관리, Core Location은 위치 서비스, Foundation 프레임워크는 기본 데이터 타입과 유틸리티 기능을 제공
- 네트워크 통신, 블루투스 연결, 위치 정보 등을 관리하며, 개발자가 여러 기능을 쉽게 활용하도록 지원

<br>

#### 미디어(Media)
- 오디오, 비디오, 그래픽 처리를 담당하는 그래픽과 멀티미디어 프레임워크를 포함
- Core Graphics, Core Animation, AVFoundation 등의 프레임워크를 통해 애니메이션, 고해상도 그래픽, 오디오 및 비디오 처리 기능을 제공
- Metal API와 같이 GPU 성능을 최적화하여 고사양 게임이나 멀티미디어 앱이 원활하게 구동될 수 있도록 지원

<br>

#### 코코아 터치(Cocoa Touch)
- 사용자와 상호작용하는 애플리케이션 레이어로, UIKit과 같은 인터페이스 구성 요소 및 제스처, 알림, 멀티태스킹 등을 담당
- 버튼, 테이블 뷰, 알림 등을 포함한 다양한 UI 요소를 제공하여, 사용자가 애플리케이션과 상호작용할 수 있도록 돕음
- Core Motion을 통해 센서 데이터를 활용할 수 있으며, 멀티터치, 터치 감지 등 사용자 인터페이스의 대부분이 이 계층에서 제공

<br>

### 요약 
- 운영체제는 하드웨어와 소프트웨어를 효율적으로 관리하여 사용자에게 원활한 환경을 제공
- iOS는 코어 OS, 코어 서비스, 미디어, 코코아 터치의 계층 구조를 통해 성능과 보안을 유지하면서 다양한 기능을 제공
- iOS의 계층화된 구조는 안정성과 효율성을 높이고, 개발자가 다양한 기능을 쉽게 활용

<br>
<br>

## 5.1 iOS의 샌드박스 구조는 어떻게 동작하나요?

<img src="https://github.com/user-attachments/assets/67aba446-240f-4551-92f1-52f4d2c292b0">

iOS의 샌드박스 구조는 **각 애플리케이션이 독립된 환경에서 실행되도록 하여 보안과 안정성을 보장하는 시스템** 입니다. 
샌드박스는 앱이 다른 앱이나 시스템의 중요한 데이터 및 리소스에 접근하지 못하게 제한하고, 필요 최소한의 권한만을 부여함으로써 보안성과 개인 정보 보호를 강화합니다.

<br>

### iOS 샌드박스 구조의 주요 동작 방식
#### 애플리케이션 별 독립 실행 환경
- iOS는 각 앱을 독립된 샌드박스 안에서 실행
- 이로 인해 각 애플리케이션은 자신만의 파일 시스템을 가지며, 다른 앱의 데이터에 접근할 수 없음
- 앱은 오직 자신이 생성한 데이터나 파일에만 접근할 수 있으며, 시스템 레벨의 데이터나 다른 앱의 파일은 기본적으로 접근이 불가능

<br>

#### 파일 시스템 격리
- 샌드박스 구조에서는 앱마다 독립된 디렉토리 구조가 제공됩니다.
- 앱은 자신의 디렉토리 내에서만 파일을 읽고 쓰기할 수 있고, 이 디렉토리는 앱이 삭제되면 함께 제거됩니다.
- 앱의 샌드박스 파일 시스템은 보통 다음과 같은 영역으로 나뉩니다
  - Documents: 사용자 문서가 저장되는 위치
  - Library: 설정 및 앱 데이터를 저장하는 위치
  - tmp: 임시 파일 저장소, 시스템이 필요시 파일을 자동으로 삭제 가능

<br>

#### 네트워크와 시스템 리소스 접근 제한
- 샌드박스는 앱이 네트워크, 카메라, 마이크, 위치 정보 등 민감한 시스템 리소스에 접근하려 할 때 사용자 권한을 요구하도록 설계되어 있습니다.
- 앱이 처음 실행될 때나 특정 기능을 요청할 때 사용자에게 권한을 요청하며, 사용자가 허용한 권한만 사용할 수 있습니다.

<br>

#### 프로세스 간 통신 제한 (Inter-Process Communication)
- 샌드박스는 앱 간의 직접적인 통신(프로세스 간 통신, IPC)을 차단하여 앱이 서로의 데이터에 직접 접근하지 못하도록 합니다.
- 앱은 URL 스킴, iOS의 앱 확장(extension) 또는 클라우드 서비스를 통해 간접적으로 통신해야 합니다.

<br>

#### 보안과 무결성 보호
- 샌드박스는 코드 서명과 앱 무결성 검사를 통해 보안성을 높입니다.
- iOS는 모든 앱을 App Store를 통해 배포하고, 코드가 변조되지 않았는지 확인하기 위해 코드 서명을 사용합니다.
- 이를 통해 iOS 기기에서 실행되는 모든 앱이 애플이 신뢰하는 코드임을 보장하고, 악성 코드로부터 시스템을 보호합니다.

<br>

### 요약
- iOS의 샌드박스 구조는 앱이 독립된 환경에서 실행되도록 하여, 다른 앱의 데이터와 시스템 리소스에 접근하지 못하도록 제한하는 보안 메커니즘입니다.
- 파일 시스템 격리, 권한 관리, 프로세스 간 통신 제한 등을 통해 보안을 강화하며, 사용자 데이터의 보호와 시스템 안정성을 유지합니다.

<br>
<br>

## 5.2 커널(Kernel)의 역할은 무엇인가요?

<img src="https://github.com/user-attachments/assets/37873b31-e12f-4604-a98b-425371f634e1">


커널은 운영체제의 핵심요소로, **하드웨어와 애플리케이션 소프트웨어 간의 중개 역할** 을 수행합니다.
커널은 **운영체제의 가장 낮은 레벨에서 작동** 하며, **시스템 자원을 관리** 하고, **프로그램이 하드웨어를 안전하고 효율적으로 사용할 수 있도록** 합니다.

<br>

### 커널의 주요 역할
#### 프로세스 관리
- 커널은 프로세스 생성, 종료, 스케줄링을 관리하ㅓ여, 여러 프로그램이 동시에 실행될 수 있도록 함
- 멀티태스킹을 지원해 CPU 가 효율적으로 프로세스를 전환하며 실행할 수 있도록 스케줄링
- 각 프로세스 간에 충돌이 없도록 보호

<br>

#### 메모리 관리
- 메모리 할당과 해제를 통해 각 프로세스가 필요한 메모리를 사용할 수 있도록 관리
- 가상 메모리 기능을 제공하여 물리적 메모리 이상으로 메모리를 확장하여, 메모리 부족 상황에서 효율적으로 처리

<br>

#### 장치 관리 (입출력 관리)
- CPU가 하드웨어 장치(디스크, 네트워크, 입력 장치 등)를 제어할 수 있도록 드라이버를 통해 통신을 관리하고, 효율적인 입출력(I/O) 처리하도록 도움
- 사용자 프로그램이 직접 하드웨어에 접근하지 못하도록 하고, 시스템 호출을 통해 간접적으로 하드웨어에 접근하도록 보안성을 유지

<br>

#### 파일 시스템 관리
- 널은 파일 생성, 삭제, 읽기 및 쓰기와 같은 파일 시스템 작업을 관리
- 파일 시스템을 통해 데이터가 안전하게 저장되고 접근 하게 함
- 여러 프로그램이 파일을 동시에 사용할 수 있도록 지원

<br>

#### 보안과 접근 제어
- 커널은 시스템의 보안과 안정성을 위해 각 프로세스의 권한을 관리
- 프로세스와 사용자 간의 접근을 제어
- 각 프로세스가 할당된 권한 내에서만 자원을 사용할 수 있도록 하여, 시스템을 보호하고 안정성을 유지

<br>

#### 인터럽트 처리
- 커널은 인터럽트가 발생했을 때 이를 처리하여, CPU가 우선순위가 높은 작업을 즉각적으로 처리
- 인터럽트 관리 덕분에 하드웨어와 소프트웨어 이벤트가 원활히 처리

<br>

### 요약 
- 커널은 운영체제의 핵심적인 소프트웨어 계층으로, 프로세스와 메모리, 파일 시스템, 입출력 장치 등을 관리하여 시스템의 자원을 효율적이고 안전하게 운영
- 커널이 하드웨어와 애플리케이션 간의 다리 역할을 함으로써, 사용자가 안전하고 안정적으로 시스템을 사용할 수 있도록 도움

<br>
<br>

## 5.3 다중 태스킹(Multitasking)은 어떻게 지원되나요?

<img src="https://github.com/user-attachments/assets/088beb43-7486-438d-9fd8-6ad10b683fd7">


### 다중 태스팅
- 운영체제가 여러 작업(프로세스 또는 스레드)을 동시에 실행하는 것처럼 관리하는 기능
- CPU 스케줄링과 프로세스 관리를 통해 이루어지며, 시스템이 유휴 상태 없이 연속적으로 작업을 처리할 수 있게 지원

### 다중 태스킹을 지원하는 주요 방식
#### 시분할(Time-sharing) 방식
- 시분할 방식은 CPU의 시간을 여러 프로세스가 짧은 시간 단위로 나눠서 사용하는 방법
- CPU가 특정 시간 동안 하나의 작업을 실행하고, 그다음 작업으로 전환
- 이 짧은 시간 단위를 타임 슬라이스(Time Slice) 또는 **퀀텀(Quantum)**이라 불림
- 사용자에게 여러 작업이 동시에 진행되는 것처럼 보임
- 선점형 스케줄링을 통해 특정 프로세스가 지정된 시간을 초과하면 CPU가 다른 프로세스에 할당
- 이를 통해 시스템 자원이 특정 작업에 독점되지 않고, 균등하게 분배

<br>

#### 프로세스와 스레드 관리
- 운영체제는 프로세스와 스레드를 생성하고 관리함으로써 다중 태스킹을 지원
- 프로세스는 독립적인 작업 단위이며, 각 프로세스는 고유한 메모리 공간을 할당
- 스레드는 프로세스 내의 작은 실행 단위로, 같은 프로세스 내에서 메모리를 공유하면서 실행
- 다중 스레드 환경에서는 한 프로세스가 여러 작업을 동시에 수행할 수 있어, 더 높은 효율성을 제공

<br>

#### CPU 스케줄링 알고리즘
- 운영체제는 다중 태스킹을 효율적으로 처리하기 위해 CPU 스케줄링 알고리즘을 사용하여 프로세스의 우선순위와 실행 순서를 결정
- 주요 스케줄링 알고리즘으로는 라운드 로빈, 우선순위 기반 스케줄링, FCFS(First-Come-First-Serve)
- 라운드 로빈 알고리즘에서는 각 프로세스에 균등한 CPU 시간을 할당하여 공정하게 실행

<br>

#### 메모리 관리
- 여러 프로세스가 동시에 실행되기 위해서는 각 프로세스가 필요한 메모리를 할당받고, 사용이 끝나면 해제되어야 함.
- 운영체제는 가상 메모리와 페이징 기법을 통해 각 프로세스가 독립된 메모리 공간을 사용하는 것처럼 처리함
- 가상 메모리를 통해 실제 물리적 메모리보다 많은 메모리 공간을 사용할 수 있게 하며, 메모리 관리 기법으로 다중 태스킹 환경을 지원

<br>

#### 인터럽트 처리
- 다중 태스킹 환경에서는 다양한 하드웨어나 소프트웨어 이벤트가 비동기적으로 발생
- 인터럽트는 CPU가 특정 작업을 중단하고, 긴급한 작업을 처리할 수 있도록 도와주는 메커니즘
- 운영체제는 인터럽트를 관리하여 우선순위가 높은 작업이 즉시 처리되도록 하며, 이를 통해 여러 작업을 효율적으로 수행


<br>

### 요약
운영체제는 시분할 방식, 프로세스와 스레드 관리, CPU 스케줄링, 메모리 관리, 인터럽트 처리 등을 통해 다중 태스킹을 지원합니다. 이를 통해 여러 작업이 동시에 실행되는 것처럼 보여주며, 시스템의 자원을 효율적으로 관리하여 사용자 경험을 향상시킵니다.


<br>
<br>

## 6. 프로세스와 스레드의 차이점, 그리고 iOS에서의 프로세스와 스레드 관리 방법에 대해 설명해주세요.

<img src="https://github.com/user-attachments/assets/8833a1cd-df8e-4f83-9e2f-2d022477cffa">

### 프로세스와 스레드의 차이점

#### 프로세스 (Process)
프로세스는 독립적인 실행 단위로, 각 프로세스는 고유한 메모리를 사용하며 iOS의 샌드박스 구조로 관리
- 각 프로세스는 고유한 메모리 공간(주소 공간)을 가지며, 다른 프로세스와 메모리를 공유하지 않습니다.
- 독립성을 유지하여 서로 간섭하지 못하게 합니다.
- 프로세스 간 데이터 교환은 어렵기 때문에, 인터프로세스 통신(IPC) 기법을 사용
- 멀티프로세스 환경에서 하나의 프로세스가 종료되더라도 다른 프로세스는 계속 실행

<br>

> Tip. 예전에는 하나의 프로세스가 한가지 일만 함. 그러다가 답답해서 스레드를 만듬 그 이유는 아래에

<br>

#### 스레드 (Thread)
스레드는 프로세스 내의 실행 단위로, 프로세스 내에서 메모리를 공유하며 빠르고 효율적인 작업 처리를 위해 사용됨
- 동일한 프로세스 내의 스레드들은 메모리를 공유하여, 상호작용이 쉽고 데이터 교환이 빠름
- 멀티스레드 환경을 통해 하나의 프로세스에서 여러 작업을 동시에 처리할 수 있으며, 자원을 효율적으로 사용할 수 있음
- 그러나 한 스레드에서 오류가 발생하면, 해당 프로세스 내의 다른 스레드까지 영향을 받음

<br>

### iOS에서의 프로세스와 스레드 관리 방법
iOS는 효율성과 안정성을 극대화하기 위해 프로세스와 스레드 관리를 철저히 합니다.
iOS는 앱이 성능을 최적화하고, 불필요한 자원 소모를 줄일 수 있도록 다양한 프레임워크와 기술을 제공합니다.

#### 프로세스 관리
- iOS는 각 앱을 독립된 샌드박스 환경에서 실행하여, 서로 다른 앱이 독립적으로 작동할 수 있도록 함
- 앱은 **포그라운드(foreground)** 와 **백그라운드(background)** 상태로 전환될 수 있으며, 백그라운드 앱은 시스템 자원을 적게 사용하게 하여 배터리 효율을 높이고 시스템 안정성을 유지
- 필요하지 않은 프로세스는 시스템이 자동으로 종료하여 자원을 해제하며, 사용자 경험을 보장하기 위해 중요한 작업은 계속 유지

<br>

#### 스레드 관리
- iOS는 멀티스레딩을 지원하며, **GCD(Grand Central Dispatch)** 와 **NSOperation** 과 같은 API를 통해 효율적인 스레드 관리를 제공
  - GCD (Grand Central Dispatch):
    - iOS에서 멀티스레드를 관리하는 API로, 백그라운드 작업을 손쉽게 분배하고 관리할 수 있도록 도움
    - GCD는 큐(queue)를 사용해 작업을 동시 또는 직렬로 실행하며, 필요한 경우 메인 스레드에서 UI 업데이트 작업을 처리할 수 있음
  - NSOperation:
    - GCD 위에 구축된 고수준 API로, 의존성, 우선순위 등 세부적인 스레드 관리가 필요한 경우에 사용
    - NSOperationQueue를 사용하면 작업 간의 의존성을 설정하고, 작업이 순서대로 실행되도록 할 수 있음
- 메인 스레드(Main Thread):
  - iOS에서는 UI 작업이 반드시 메인 스레드에서 처리되어야 함
  - 따라서, 백그라운드에서 긴 작업을 수행한 후 UI 업데이트가 필요할 때는 메인 스레드에서 처리해야함

#### 백그라운드 작업 처리
- iOS는 **백그라운드에서 작업을 수행할 수 있는 제한된 시간** 을 제공합니다.
  - 예) 앱이 백그라운드로 전환될 때 짧은 작업은 완료할 수 있으며, 이를 위해 iOS는 background task API를 제공
- 다운로드, 위치 서비스와 같은 지속적인 백그라운드 작업을 필요로 할 경우 Background Modes를 설정하여 시스템의 허가를 받아야함

<br>

### 요약
- 프로세스는 독립적인 실행 단위로, 각 프로세스는 고유한 메모리를 사용하며 iOS의 샌드박스 구조로 관리됨
- 스레드는 프로세스 내의 실행 단위로, 프로세스 내에서 메모리를 공유하며 빠르고 효율적인 작업 처리를 위해 사용됨
- iOS는 GCD와 NSOperation을 통해 멀티스레드 환경을 제공하고, 백그라운드 작업 및 메인 스레드에서의 UI 처리를 체계적으로 관리
- 이를 통해 성능 최적화와 안정성을 동시에 유지

<br>
<br>


## 6.1 멀티스레딩이 필요한 이유는 무엇인가요?

<img src="https://github.com/user-attachments/assets/5082d5cb-8c84-4953-86ed-418e4360f4c0">

멀티스레딩은 한 프로세스 내에서 여러 스레드를 동시에 실행하여 작업을 병렬로 처리하는 방식

<br>

### 멀티스레딩이 필요한 이유
#### 프로그램의 응답성 향상
- 멀티스레딩을 사용하면, 메인 스레드가 긴 작업(예: 네트워크 통신, 파일 입출력) 동안 차단되지 않아, 사용자 인터페이스(UI)가 즉각 반응할 수 있음
  - 예) 모바일 앱에서 사진이나 동영상을 다운로드하면서도, 사용자는 화면을 스크롤하거나 버튼을 누르는 등 다른 작업을 할 수 있음

<br>

#### CPU 자원 최적화
- 멀티코어 CPU 환경에서는 각 코어에서 동시에 여러 스레드를 실행할 수 있어, CPU 자원을 최대한 활용할 수 있음
- 각 코어가 독립적인 스레드를 실행함으로써 여러 작업을 병렬로 수행할 수 있기 때문에 프로그램이 더 빠르고 효율적으로 실행

<br>

#### 복잡한 작업의 병렬 처리
- 큰 작업을 작은 단위로 나누어 여러 스레드에서 병렬로 처리함으로써 처리 시간을 단축
  - 예) 이미지나 비디오 처리를 여러 스레드로 분할해 동시에 처리하면 전체 작업 시간이 줄어듬
- 이를 통해 실시간으로 처리해야 하는 작업이나, 대량의 데이터를 다루는 작업에서 성능이 크게 향상  

<br>

#### 자원 공유와 협업 가능
- 멀티스레딩을 통해 공유 자원을 여러 스레드가 협력하여 사용함으로써 프로그램의 구조와 효율을 개선
  - 예) 웹 서버는 멀티스레딩을 통해 여러 사용자의 요청을 동시에 처리하며, 각 스레드는 데이터를 공유하고 동시에 작업을 진행할 수 있음

<br>

#### 비동기 작업 수행
- 멀티스레딩을 사용하면 네트워크 요청이나 파일 입출력과 같은 비동기 작업을 백그라운드에서 수행 가능
- 메인 스레드는 다른 작업을 계속 처리하고, 백그라운드 작업이 완료되면 결과를 받아서 처리하는 방식으로 동작
  - 예) iOS의 GCD(Grand Central Dispatch)는 멀티스레딩을 통해 비동기적으로 작업을 수행하고, 작업이 완료되면 UI 스레드로 돌아와 업데이트를 처리할 수 있도록 지원

<br>

### 요약
멀티스레딩은 프로그램이 더 빠르게 실행되고 사용자에게 즉각적인 응답을 제공할 수 있도록 합니다. CPU 자원을 최대한 활용하여 성능을 높이고, 긴 작업을 백그라운드에서 처리함으로써 사용자 경험을 개선할 수 있습니다.

<br>
<br>



## 6.2 iOS에서 GCD(Grand Central Dispatch)는 어떤 역할을 하나요?

<img src="https://github.com/user-attachments/assets/905e8deb-45ed-4594-a2d2-e6043c10c0d0">

**GCD(Grand Central Dispatch)** 는 iOS에서 효율적으로 멀티스레딩을 구현하고, 비동기 작업을 간단히 관리할 수 있도록 해주는 저수준의 API

<br>

### GCD의 주요 역할
#### 비동기 작업 처리
- GCD를 사용하면 비동기적으로 작업을 실행할 수 있어, 메인 스레드(UI 스레드)가 긴 작업(예: 네트워크 요청, 파일 다운로드)으로 차단되지 않도록 할 수 있음
- 비동기 작업은 백그라운드에서 실행되며, 완료 후 메인 스레드에서 결과를 처리하게 하여 앱의 응답성을 유지
  
<br>

#### 멀티스레드 관리
- GCD는 개발자가 스레드를 직접 생성하고 관리할 필요 없이, 큐(queue)를 통해 여러 작업을 효율적으로 관리할 수 있게 함
- 작업을 직렬 큐(Serial Queue) 또는 **동시 큐(Concurrent Queue)** 에 추가하여 실행 방식(순차 실행 또는 병렬 실행)을 정할 수 있음
- 이를 통해 멀티코어 프로세서에서 CPU 자원을 최적화하고 작업을 병렬로 수행할 수 있음

<br>

#### 작업 큐 관리
- GCD는 작업 큐를 통해 작업을 관리하고 실행합니다. **작업 큐(Dispatch Queue)** 는 작업이 실행될 순서와 방식을 결정하며, GCD는 큐를 통해 작업을 효율적으로 할당
- GCD의 작업 큐 종류
  - 직렬 큐(Serial Queue): 작업을 하나씩 순차적으로 실행
  - 동시 큐(Concurrent Queue): 여러 작업을 동시에 병렬로 실행
  - 메인 큐(Main Queue): 메인 스레드에서 실행되어, UI 업데이트와 같은 작업을 처리함

<br>

#### 메인 스레드에서의 UI 업데이트
- iOS에서는 UI 관련 작업은 반드시 메인 스레드에서 실행해야 함.
- GCD는 DispatchQueue.main을 통해 비동기 작업 후 UI를 안전하게 업데이트할 수 있도록 지원
  - 예) 백그라운드에서 데이터를 다운로드한 후 메인 스레드에서 UI를 업데이트하는 것이 가능

<br>

#### QoS (Quality of Service) 설정
- GCD는 작업의 **우선순위(Quality of Service, QoS)** 를 설정하여 중요도에 따라 CPU 리소스를 효율적으로 할당할 수 있음
- QoS는 주로 다음과 같은 레벨로 구성
  - User-interactive: UI 업데이트나 사용자와 직접적으로 상호작용하는 작업 (최고 우선순위)
  - User-initiated: 사용자 요청에 의해 발생한 작업으로, 빠른 응답이 필요
  - Utility: 다운로드, 데이터 처리 등 시간 소모가 큰 작업
  - Background: 백그라운드 데이터 업데이트 등 낮은 우선순위의 작업

<br>

```swift

DispatchQueue.global(qos: .userInitiated).async {
    // 백그라운드에서 실행할 작업
    
    DispatchQueue.main.async {
        // 메인 스레드에서 실행할 작업 (예: UI 업데이트)
    }
}

```

<br>

### 요약
GCD는 iOS에서 멀티스레딩과 비동기 작업 관리를 위해 설계된 API로, 앱의 성능을 최적화하고 사용자 경험을 개선하는 역할을 합니다. GCD는 큐와 QoS를 통해 작업을 효율적으로 배분하며, 메인 스레드에서의 UI 업데이트도 안전하게 관리할 수 있도록 지원합니다.

  
<br>
<br>

## 7. 메모리 관리 기법 중 iOS에서 사용되는 방식과 그 특징에 대해 설명해주세요.

<img src="https://github.com/user-attachments/assets/3ff2fe33-2b2c-4987-8050-8b41de72cffc">

iOS에서는 **ARC (Automatic Reference Counting)** 라는 메모리 관리 기법을 사용합니다. ARC는 앱이 사용하는 메모리를 효율적으로 관리하기 위해 객체의 참조 카운트를 자동으로 조정하여, 더 이상 필요하지 않은 객체를 메모리에서 해제합니다. 다음은 iOS의 ARC 메모리 관리 기법과 그 특징입니다.

<br>

### Automatic Reference Counting (ARC)
ARC는 Swift와 Objective-C에서 사용하는 자동 메모리 관리 시스템입니다. 각 객체에 대해 **참조 횟수(Reference Count)** 를 추적하며, 참조가 0이 되면 객체를 메모리에서 해제합니다.


<br>

#### 주요 특징:
- 자동관리 :
  - ARC는 컴파일러 수준에서 자동으로 관리되므로, 개발자가 명시적으로 메모리를 할당하거나 해제할 필요가 없음
- 참조 카운트 기반 :
  - 객체가 생성될 때마다 참조 카운트가 증가하고, 더 이상 참조되지 않으면 카운트가 감소.
  - 카운트가 0이 되면 메모리가 해제
- 성능 최적화 :
  - 수동으로 메모리를 관리하는 것보다 오류 발생 가능성이 낮으며, 대부분의 경우 성능 면에서도 최적화되어 있음
 
<br>

#### 참조 타입의 종류와 순환 참조 해결:
iOS에서는 ARC의 특성을 활용해 참조 타입의 종류를 다르게 사용함으로써 **순환 참조(Circular Reference)** 를 방지합니다. 순환 참조는 두 객체가 서로를 강한 참조로 가지게 되어, 참조 카운트가 0이 되지 않아 메모리에서 해제되지 않는 문제입니다. 이를 방지하기 위해 다음의 참조 타입이 사용됩니다.

<br>

- 강한 참조(Strong Reference) :
  - 기본적인 참조 방식으로, 참조하는 객체의 카운트를 증가
  - 두 객체가 서로 강한 참조를 가지면 순환 참조 문제가 발생할 수 있음

```swift
class Person {
    var pet: Pet?  // 기본적으로 강한 참조
    deinit { print("Person is being deinitialized") }
}

class Pet {
    var owner: Person?  // 기본적으로 강한 참조
    deinit { print("Pet is being deinitialized") }
}

// 사용 예시
var person: Person? = Person()
var pet: Pet? = Pet()

person?.pet = pet  // Person이 Pet을 강하게 참조
pet?.owner = person // Pet이 Person을 강하게 참조

person = nil       // 순환 참조로 인해 deinit 호출되지 않음
pet = nil          // 순환 참조로 인해 deinit 호출되지 않음

```

<br>

- 약한 참조(Weak Reference) :
  - 참조는 하되 참조 카운트를 증가시키지 않는 방식
  - weak 키워드로 선언하며, 참조 대상 객체가 메모리에서 해제되면 nil이 됨
  - 주로 delegate 패턴에서 사용
 
```swift
class Person {
    var pet: Pet?
    deinit { print("Person is being deinitialized") }
}

class Pet {
    weak var owner: Person?  // 약한 참조
    deinit { print("Pet is being deinitialized") }
}

// 사용 예시
var person: Person? = Person()
var pet: Pet? = Pet()

person?.pet = pet         // Person이 Pet을 강하게 참조
pet?.owner = person       // Pet이 Person을 약하게 참조

person = nil              // Person이 해제되고, 약한 참조로 순환 참조가 발생하지 않음
// 출력: "Person is being deinitialized"
pet = nil                 // Pet도 해제됨
// 출력: "Pet is being deinitialized"
```

<br>

- 비소유 참조(Unmanaged Reference) :
  - unowned 키워드를 사용하여 참조 카운트를 증가시키지 않지만, 참조 대상이 해제되더라도 nil이 됨
  - 참조 대상이 해제되기 전에만 사용해야 함
  - 주로 강한 순환 참조를 방지하는 데 사용됨


```swift
class Customer {
    var creditCard: CreditCard?
    deinit { print("Customer is being deinitialized") }
}

class CreditCard {
    unowned let customer: Customer  // 비소유 참조
    init(customer: Customer) {
        self.customer = customer
    }
    deinit { print("CreditCard is being deinitialized") }
}

// 사용 예시
var customer: Customer? = Customer()
customer?.creditCard = CreditCard(customer: customer!)

customer = nil  // CreditCard도 해제됨
// 출력: "Customer is being deinitialized"
// 출력: "CreditCard is being deinitialized"

```


<br>

#### ARC와 메모리 관리의 주요 특징
- 컴파일 타임에 관리:
  - ARC는 런타임이 아니라 컴파일 타임에 코드에 삽입되므로, 자동 메모리 관리가 매우 효율적으로 작동
- 메모리 누수 방지:
  - 강한 순환 참조를 피하고 약한 참조와 비소유 참조를 적절히 사용하여 메모리 누수를 방지
- 비동기 코드에서 주의:
  - 클로저 내부에서 self를 강하게 캡처하면 메모리 누수가 발생
  - 이를 방지하기 위해 [weak self]를 사용해 약하게 캡처
 
<br>

#### ARC가 관리하지 않는 메모리
ARC는 객체 인스턴스에 대해서만 메모리를 관리

<br>

- C언어 스타일의 메모리 할당 :
  - malloc이나 free와 같은 C 언어의 메모리 관리 방식은 ARC에서 관리되지 않음
- Core Graphics 객체 :
  - CGContext, CGColor 등 Core Graphics에서 사용하는 객체는 ARC의 대상이 아니며, 수동으로 해제해야함
- Unmanaged 객체 :
  - Swift와 Objective-C 간의 브릿징을 통해 생성된 Unmanaged 객체도 ARC의 관리 대상이 아님
 
<br>

#### 메모리 관리 관련 키워드
- weak과 unowned는 ARC에서 순환 참조를 방지하기 위해 사용됩니다.
- @autoreleasepool:
  - iOS에서는 큰 메모리 작업이나 비동기 작업에서 메모리 사용량을 줄이기 위해 @autoreleasepool 블록을 사용하여 자동 해제를 조절할 수 있습니다.

<br>

### 요약
iOS의 메모리 관리 기법인 ARC는 객체의 참조 카운트를 기반으로 자동 메모리 해제를 수행하여, 개발자가 직접 메모리 해제를 관리하지 않아도 되도록 돕습니다. 강한 참조, 약한 참조, 비소유 참조 등을 적절히 사용하여 순환 참조 문제를 해결하며, ARC가 관리하지 않는 요소에 대해 추가적인 메모리 관리도 필요할 수 있습니다.




<br>
<br>

## 7.1 자동 참조 카운팅(ARC)은 어떻게 동작하나요?
- ARC는 iOS와 macOS에서 메모리를 자동으로 관리하는 시스템
- 객체가 생성될 때마다 참조 카운트가 증가
- 더 이상 참조되지 않으면 참조 카운트가 0으로 줄어들고, 메모리에서 자동으로 해제됨
- ARC는 컴파일러 수준에서 자동으로 관리되므로, 개발자가 명시적으로 메모리를 할당하거나 해제할 필요가 없음

<br>
<br>

## 7.2 Garbage Collection과의 차이는 무엇인가요?

<img src="https://github.com/user-attachments/assets/4dce7650-e7b2-4df6-8b3f-779c74317253">

### 결론
ARC와 GC 모두 자동 메모리 관리 방식을 제공하지만, ARC는 참조 카운트 기반이고 컴파일 타임에 관리되는 반면, GC는 주기적으로 메모리를 스캔하여 관리합니다. ARC는 보다 일관된 성능을 제공하지만 순환 참조에 주의해야 하며, GC는 개발자가 메모리 관리에 덜 신경 쓰도록 도와주지만 성능에 일시적인 영향을 미칠 수 있습니다.

<br>

> - 컴파일 타임 시점 :
>   - 코드를 작성한 후 빌드를 돌릴 때 발생하며, 코드를 기계어로 변환하고 에러 검사를 하는 시점입니다.
> - 런타임 시점 : 
>   - 앱이 실제로 기기에서 실행되는 시점으로, 사용자의 인터랙션에 따라 동작하며, 앱이 종료될 때까지 유지됩니다.

<br>
<br>

## 8. iOS의 샌드박스(Sandbox) 개념과 역할, 그리고 앱 간 데이터 공유 방법에 대해 설명해주세요.
**iOS의 샌드박스(Sandbox)** 는 각 앱이 독립된 환경에서 실행되도록 격리하는 보안 구조입니다. 이는 앱이 시스템 리소스나 다른 앱의 데이터에 무분별하게 접근하지 못하도록 막아주는 역할을 합니다. 이로 인해 iOS는 높은 수준의 보안을 유지할 수 있으며, 사용자의 데이터를 보호할 수 있습니다.

### 샌드박스(Sandbox) 개념과 역할
- 개념 :
  - iOS에서 샌드박스는 각 앱에 고유한 디렉토리 구조와 권한을 부여하여 외부로부터 격리된 환경에서 실행되도록 하는 보안 구조
- 역할 :
  - 데이터 보호 :
    - 각 앱의 데이터는 다른 앱에서 접근할 수 없으므로, 사용자의 개인 정보와 파일이 보호
  - 시스템 보호 :
    - 앱이 시스템 리소스나 운영체제의 중요한 부분에 직접 접근하지 못하게 하여, 앱의 오류나 악성 코드가 시스템에 영향을 미치지 않도록 함
  - 안정성 유지 :
    - 앱이 오류로 인해 강제 종료되더라도 다른 앱이나 시스템에 영향을 미치지 않으므로 iOS의 안정성을 높임

<br>

### 샌드박스에서의 앱 파일 구조
각 앱은 iOS에서 고유의 디렉토리를 할당받으며, 일반적으로 다음과 같은 구조를 가지고 있습니다:

#### Documents :
- 앱의 주요 데이터가 저장되는 폴더로, 사용자가 생성한 파일이나 데이터가 저장
  
#### Library :
- 캐시 및 설정 파일이 저장되는 폴더
  - Caches : 임시 데이터를 저장하는 데 사용되며, 시스템에 의해 삭제될 수 있음
  - Preferences : 설정 파일이 저장되는 폴더로, UserDefaults 데이터가 저장

#### tmp :
- 임시 파일을 저장하는 폴더로, 앱이 종료되면 삭제될 수 있음

<br>

### 앱 그룹과 URL Scheme, Universal Links 외 앱 데이터 공유 방법

#### UIDocumentInteractionController
- UIDocumentInteractionController를 사용하여 다른 앱으로 파일을 전송할 수 있습니다.
- 이 방법은 앱에서 특정 파일을 공유할 때, 사용자가 해당 파일을 열 수 있는 다른 앱을 선택하도록 합니다.
- 예를 들어, PDF 파일을 이메일 앱이나 파일 뷰어 앱으로 보낼 때 사용할 수 있습니다.

<br>

#### UIPasteboard
- UIPasteboard를 통해 간단한 데이터를 복사하고 붙여넣기 형식으로 앱 간에 전송할 수 있습니다.
- 사용자가 데이터를 복사하여 다른 앱에 붙여넣거나, 특정 데이터를 복사하여 여러 앱이 접근하도록 설정할 수 있습니다.

<br>

### 요약
iOS의 샌드박스는 각 앱을 독립된 환경에서 실행하여 보안을 유지하고, 시스템과 다른 앱에 영향을 주지 않도록 보호합니다. 앱 간 데이터 공유는 기본적으로 차단되지만, App Groups, UIDocumentInteractionController, URL Scheme와 Universal Links, UIPasteboard와 같은 공식적인 방법을 통해 안전하게 데이터를 공유할 수 있습니다.

<br>
<br>

## 8.1 URL 스킴(URL Scheme)을 이용한 앱 간 통신은 어떻게 이루어지나요?

<img src="https://github.com/user-attachments/assets/4964e935-2334-46f9-864d-15f0745324ee">

### URL 스킴(URL Scheme)
#### 개념
- URL 스킴은 앱을 열기 위해 사용하는 맞춤형 URL 프로토콜입니다.
- iOS에서는 특정 URL 스킴이 설정된 경우, 해당 URL을 통해 앱을 호출하고, 특정 화면으로 이동하거나 기능을 수행하도록 설정할 수 있습니다.
- 예) myapp://profile?userID=1234라는 URL을 호출하면 myapp이라는 스킴을 가진 앱이 실행되며, profile 화면이 열리고, userID=1234라는 파라미터가 전달될 수 있습니다.

<br>


#### 설정 방법
1. Xcode에서 URL 스킴 등록: 프로젝트의 Info.plist 파일에서 URL Types에 맞춤형 스킴을 추가합니다.

```xml
<key>CFBundleURLTypes</key>
<array>
    <dict>
        <key>CFBundleURLName</key>
        <string>com.example.myapp</string>
        <key>CFBundleURLSchemes</key>
        <array>
            <string>myapp</string>
        </array>
    </dict>
</array>

```

<br>

2. 앱 내에서 URL 처리: 앱이 열릴 때 전달된 URL을 감지하고 처리할 수 있도록 AppDelegate의 application(_:open:options:) 메서드를 구현합니다.

```swift
func application(_ app: UIApplication, open url: URL, options: [UIApplication.OpenURLOptionsKey : Any] = [:]) -> Bool {
    // URL 스킴을 확인하고 적절히 처리
    if url.scheme == "myapp" {
        // URL path 및 query items를 통해 화면 전환 및 데이터 전달 처리
        return true
    }
    return false
}

```

<br>

#### URL 스킴의 사용 예
- 앱 간의 간단한 데이터 전달 :
  - 다른 앱에서 특정 기능이나 화면을 열도록 요청할 때 사용됩니다.
- 앱의 특정 화면으로 바로 이동 :
  - 예를 들어, 특정 상품 상세 페이지나 설정 화면으로 바로 이동할 때 유용합니다.

<br>

### Universal Links

#### 개념
- Universal Links는 일반적인 HTTPS 링크를 통해 앱을 열도록 설정하는 방식
- 사용자가 Safari나 다른 앱에서 특정 링크를 누르면, 해당 URL이 설정된 앱이 설치되어 있는 경우 앱이 열리고, 앱이 설치되어 있지 않은 경우 웹사이트로 연결
- Universal Links는 URL 스킴과 달리, 사용자가 인지하지 못한 상태로 앱을 열 수 있으며, 보안과 유연성 면에서 URL 스킴보다 높은 수준의 사용자 경험을 제공

<br>

#### 설정 방법
1. Associated Domain 설정:
- Xcode 프로젝트에서 Signing & Capabilities > Associated Domains에서 applinks:example.com 형식으로 앱의 도메인을 추가합니다.

<br>

2. 애플 사이트 연관 파일 생성:
- 웹 서버에 apple-app-site-association 파일을 생성하고, 앱과 연관된 도메인을 설정합니다.
- 예시 파일 (https://example.com/apple-app-site-association):

```swift
{
  "applinks": {
    "apps": [],
    "details": [
      {
        "appID": "<Team ID>.<Bundle Identifier>",
        "paths": [ "/profile/*", "/product/*" ]
      }
    ]
  }
}
```

<br>

3. 앱 내에서 URL 처리:
- Universal Link가 앱에서 열리면, SceneDelegate의 scene(_:continue:) 메서드가 호출됩니다.

```swift
func scene(_ scene: UIScene, continue userActivity: NSUserActivity) {
    if userActivity.activityType == NSUserActivityTypeBrowsingWeb,
       let url = userActivity.webpageURL {
        // URL 경로 및 파라미터를 처리
    }
}
```

<br>

#### Universal Links의 사용 예
- 웹과 앱의 통합된 경험 제공:
  - 사용자가 웹에서 링크를 클릭할 때, 앱이 열리도록 하여 원활한 사용자 경험을 제공할 수 있습니다.
- 앱이 설치되지 않은 경우 웹으로 연결:
  - Universal Links는 앱 설치 여부에 따라 앱 또는 웹으로 유연하게 연결됩니다.
- 보안이 강화된 통신:
  - HTTPS 기반 링크만 허용되어, 외부에서 URL을 무작위로 호출하여 앱을 열지 못하도록 보안이 강화됩니다.

<br>

#### URL 스킴과 Universal Links의 차이점 요약

<img src="https://github.com/user-attachments/assets/18021cca-f7f7-4c9b-82df-d7cd7c7a388b">

<br>

#### 요약 
- URL 스킴:
  - 앱 간 간단한 데이터 전달 및 특정 기능을 호출하는 데 사용되며, 주로 앱 내부에서 특정 화면이나 기능으로 이동할 때 유용합니다.
- Universal Links:
  - 웹과 앱을 통합하는 사용자 경험을 제공하며, 앱이 설치되어 있지 않은 경우 웹 사이트로 유연하게 연결됩니다. 보안이 강화되어 있으며 HTTPS 기반 링크만 사용 가능합니다.

<br>
<br>


## 8.2 앱 그룹(App Group)을 활용하여 데이터 공유를 하는 방법은 무엇인가요?

<img src="https://github.com/user-attachments/assets/22a1d76f-9735-4354-a953-e2694bcb3ea2">

[AppGroupConfigure](https://developer.apple.com/documentation/xcode/configuring-app-groups)


App Groups는 동일한 개발자가 만든 여러 앱 간의 데이터 공유를 가능하게 합니다.

### 설정 방법 및 구성

#### Apple Developer Center에서 App Group 설정 :
1. 개발자가 Apple Developer Center에서 App Group ID를 생성
2. Xcode에서 해당 App Group을 프로젝트에 추가

- 이렇게 해야 App Group을 통한 공유 컨테이너에 접근할 수 있습니다.

<br>


#### 앱 타겟 설정 :
1. 각 앱의 Xcode 프로젝트에서 App Group 설정을 추가
2. 해당 App Group을 타겟의 Signing & Capabilities에 추가

- App Group ID가 일치하는 모든 앱이 같은 그룹 컨테이너에 접근할 수 있습니다.

<br>

#### 샌드박스 환경 고려
iOS 샌드박스 환경에서 App Groups은 앱이 자체적으로 접근 가능한 제한된 영역을 확장 여러 앱이 공유하는 컨테이너로 제한적으로 접근할 수 있도록 허용합니다.

<br>

### App Groups에서 공유 가능한 데이터 유형
#### UserDefaults: 
- UserDefaults를 사용하여 App Groups에 저장된 데이터를 여러 앱에서 공유할 수 있음

```swift
if let sharedDefaults = UserDefaults(suiteName: "group.com.example.appgroup") {
    sharedDefaults.set("exampleValue", forKey: "exampleKey")
}
```
이 코드에서는 UserDefaults의 suiteName으로 App Group을 지정하여, 여러 앱에서 접근 가능한 UserDefaults를 만듭니다.

<br>

#### 파일 및 디렉토리 데이터: 
- 파일과 같은 데이터는 App Group 컨테이너의 파일 경로를 통해 접근할 수 있습니다.
```swift

if let sharedContainerURL = FileManager.default.containerURL(forSecurityApplicationGroupIdentifier: "group.com.example.appgroup") {
    let fileURL = sharedContainerURL.appendingPathComponent("sharedFile.txt")
    // 파일 쓰기 예시
    try? "Shared Data".write(to: fileURL, atomically: true, encoding: .utf8)
}

```
이 코드는 App Group 공유 컨테이너 내에 sharedFile.txt 파일을 저장하여 다른 앱에서도 접근할 수 있게 합니다.

<br>

### App Groups 활용 예시
- 로그인 세션 및 사용자 설정 공유 :
  - 여러 앱에서 동일한 로그인 상태나 사용자 설정을 유지하려는 경우, 하나의 앱에서 로그인 정보를 설정하고, 다른 앱에서 이를 확인할 수 있습니다.
- 건강 관련 데이터 앱 :
  - 건강 앱이나 피트니스 관련 앱에서 사용자 데이터를 공유하고, 한 앱에서 기록된 데이터를 다른 앱에서도 접근할 수 있게 만듭니다.
- 위젯(Widget) :
  - iOS 위젯은 App Group을 사용하여 본 앱과 데이터를 공유합니다.
  - 예를 들어, 날씨 앱이 위젯을 통해 현재 날씨를 보여주기 위해 데이터를 공유하는 방식입니다.


<br>

### 데이터 동기화 및 업데이트 처리
- 데이터 동기화:
  - App Group을 사용할 때 데이터가 즉각적으로 동기화되지 않을 수 있으므로, UserDefaults에 데이터 업데이트 후 synchronize() 메서드를 호출하여 데이터를 바로 반영할 수 있습니다. 그러나 이 메서드는 자동 동기화 속도를 높이기 위한 선택 사항이며, 실제로는 대부분의 상황에서 불필요한 경우가 많습니다.
- 앱 실행 중 데이터 변경 감지:
  - 앱 실행 중 다른 앱에 의해 데이터가 변경될 가능성이 있을 때, NotificationCenter를 통해 데이터 변경을 알림으로써 앱 간 데이터 변경을 실시간으로 감지할 수 있습니다.

<br>

### 보안 및 접근 권한 관리
- 보안 고려:
  - App Group의 데이터는 앱 간에 공유되지만, 여전히 샌드박스 환경 내에서 보안이 보장됩니다.
  - 그러나, App Group ID가 다른 앱 간에는 접근이 불가능하므로 다른 개발자가 접근할 수 없습니다.
- 앱 업데이트 시 주의사항:
  - App Group을 사용하는 앱을 업데이트할 때는, App Group 설정이 삭제되거나 변경되지 않도록 주의해야 합니다.
  - App Group 설정을 변경하면 기존의 공유 데이터가 삭제될 수 있습니다.


<br>


### 요약 
- App Groups은 UserDefaults와 파일 데이터를 공유하기 위해 사용되며, 설정을 위해 Apple Developer Center와 Xcode 설정이 필요합니다.
- 여러 앱 간에 로그인 정보, 설정, 위젯 데이터를 공유하는 데 사용됩니다.
- 보안 유지와 함께 즉각적인 데이터 동기화를 위해 NotificationCenter와 synchronize() 메서드로 업데이트를 관리할 수 있습니다.


<br>
<br>

## 9. iOS에서의 메모리 구조와 관리 방식에 대해 자세히 설명해주세요.

<img src="https://github.com/user-attachments/assets/23705085-c99f-4cae-9200-d3b81334a434">


### iOS의 메모리 구조
iOS의 메모리 공간은 코드, 데이터, 힙, 스택과 같은 영역으로 구분됩니다. 각 영역은 서로 다른 용도와 관리 방식을 가지고 있습니다.

<br>

#### 코드(Code) 영역
- 역할 :
  - 소스코드가 기계어 형태로 저장
  - 앱의 실행 코드가 저장되는 영역으로, 앱이 시작할 때 메모리에 로드됩니다.
  - CPU가 여기에 저장된 명령어를 하나씩 가져가 처리한다
  - 프로그램 시작~종료까지 메모리에 있게 된다.
- 특징 :
  - 일반적으로 읽기 전용이며, 코드가 변경되지 않기 때문에 안정성과 보안을 유지할 수 있습니다.
- 용도 :
  - 컴파일된 바이너리 코드와 함수, 메서드 등의 실행 코드가 포함됩니다. 

<br>

#### 데이터(Data) 영역

<img src="https://github.com/user-attachments/assets/21aebe05-5a20-4fb1-b44a-de8abbf32fc0">

- 역할 :
  - global변수, static변수가 저장된다.
  - 프로그램 시작과 동시에 할당, 종료되면 메모리를 해제하게 된다.
  - 조금 더 자세히 알아보면, 일반적인 메모리의 데이터 영역은 data영역과 bss영역으로 나뉘고 각기 다른 데이터가 저장된다.
    - data 영역 : 초기화 된 데이터
    - BSS (Block Stated Symbol) 영역 : 초기화 되지 않은 데이터
- 특징 :
  - 전역적으로 접근 가능한 변수는 데이터 영역에 저장되며, 앱 실행 동안 유지됩니다.
- 구분 :
  - 읽기 전용 영역과 읽기/쓰기 가능한 영역으로 나누어지며, 상수와 변수가 분리되어 저장됩니다.

<br>

#### 힙(Heap) 영역
- 역할 :
  - 동적 할당 영역
  - 런타임에 크기가 결정
  - 런타임에 생성된 객체나 데이터가 이곳에 저장
- 특징 :
  - 할당과 해제가 동적으로 이루어지며, 메모리 사용량이 증가하면 크기가 확장될 수 있습니다.
- 관리 방식:
  - iOS에서는 ARC를 사용하여 힙 영역의 메모리를 관리하며, 참조 카운트를 통해 필요 없는 객체를 자동으로 해제합니다.
- 용도 :
  - 힙 영역은 앱의 동작 중에 생성되고 메모리에서 사라져야 하는 객체들(예: 클래스 인스턴스)을 위한 공간입니다.

<br>

#### 스택(Stack) 영역
- 역할:
  - 지역변수, 매개변수, 포인터 등이 저장되는 영역
- 특징:
  - LIFO(Last In, First Out) 방식으로 메모리를 관리하여, 함수가 종료되면 자동으로 메모리가 해제됩니다.
  - 컴파일타임에 크기 결정
- 관리 방식:
  - 스택은 시스템이 자동으로 메모리를 관리하며, 개발자가 별도로 관리하지 않아도 됩니다.
- 용도:
  - 메서드 호출 시의 파라미터와 리턴 주소, 지역 변수가 저장됩니다.
  - 함수가 호출될 때마다 스택에 쌓이고, 함수가 종료되면 해제됩니다.
 
<br>

### iOS 메모리 관리 최적화 방법

#### 1.	메모리 경고 처리
- iOS에서는 앱이 메모리를 과도하게 사용할 때 메모리 경고가 발생합니다.
- 이때 UIApplicationDelegate의 applicationDidReceiveMemoryWarning 메서드를 통해 메모리 해제를 위한 처리를 할 수 있습니다.
  
<br>

#### 2.	이미지 캐싱 및 메모리 관리
- 이미지를 자주 사용하거나 고화질 이미지를 로드하는 경우, 이미지 캐싱을 통해 메모리 사용을 줄일 수 있습니다.
- NSCache를 사용하여 메모리 사용량을 최적화할 수 있습니다.

<br>

#### 3. 강한 순환 참조 방지
- 클로저 내부에서 self를 캡처할 때 [weak self] 또는 [unowned self]를 사용하여 순환 참조를 방지할 수 있습니다.

<br>

#### 적절한 메모리 해제 시점 관리
- 객체가 더 이상 필요하지 않을 때는 즉시 nil을 할당하여 메모리에서 해제될 수 있도록 합니다.

<br>

#### 비동기 작업 메모리 관리
- 비동기 작업이나 콜백에서 사용되는 객체들은 필요할 때만 강한 참조로 유지하고, 작업이 끝나면 참조를 해제하여 메모리 누수를 방지합니다.

<br>
<br>

## 9.1 힙(Heap)과 스택(Stack)의 차이점은 무엇인가요?

<img src="https://github.com/user-attachments/assets/c32a6ebe-842e-4c06-b3a4-85e141c0841d">

### 힙(Heap)
- 동적 메모리 할당:
  - 힙은 동적 메모리 할당이 이루어지는 공간입니다.
  - 런타임에 할당이 이루어지며, 클래스 인스턴스, 큰 배열 등 크기가 가변적인 데이터가 저장됩니다.
- 메모리 관리 방식:
  - iOS에서는 ARC(Automatic Reference Counting)를 통해 힙 영역에 할당된 메모리를 자동으로 관리합니다.
  - 사용 후에도 참조 카운트가 남아있으면 메모리가 해제되지 않아 메모리 누수가 발생할 수 있습니다.
- 유연성:
  - 힙은 프로그램이 실행 중일 때 필요한 만큼 메모리를 할당할 수 있으므로 유연성이 높지만, 메모리 접근 속도가 상대적으로 느립니다.
 
```swift
class Person {
    var name: String
    init(name: String) {
        self.name = name
    }
}

let person = Person(name: "John")  // 힙에 메모리 할당
```
<br>

### 스택(Stack)
- 정적 메모리 할당:
  - 스택은 정적 메모리 할당이 이루어지는 공간으로, 함수 호출 시 생성되는 지역 변수, 함수의 매개변수, 리턴 주소 등이 저장됩니다.
- 자동 관리:
  - 스택은 LIFO(Last In, First Out) 구조로 함수가 호출되면 스택에 메모리가 쌓이고, 함수가 종료되면 자동으로 해제됩니다.
  - 개발자가 직접 메모리 해제를 관리할 필요가 없습니다.
- 빠른 접근 속도:
  - 스택은 연속적인 메모리 공간에 저장되어, 할당과 해제가 매우 빠릅니다.
  - 그러나 할당 가능한 크기가 제한적이어서 대규모 데이터를 저장하기에는 적합하지 않습니다.
 
```swift
func calculateSum() {
    let x = 10   // 스택에 저장
    let y = 20   // 스택에 저장
    let sum = x + y // sum도 스택에 저장
    print(sum)
}

calculateSum() // 함수 호출 시 스택에 메모리가 쌓이고, 종료되면 자동 해제
```

<br>
<br>

## 10. 네트워크 프로토콜 스택과 iOS에서의 네트워크 통신 방식에 대해 설명해주세요.

<img src="https://github.com/user-attachments/assets/8046dcbe-342f-43ac-87d9-33f5cb9ad021">

### 네트워크 프로토콜 스택
네트워크 프로토콜 스택은 인터넷 통신을 처리하기 위해 프로토콜을 계층별로 구성한 체계입니다. 일반적으로 OSI 7계층 모델 또는 TCP/IP 4계층 모델로 설명되며, iOS는 주로 TCP/IP 모델을 기반으로 네트워크 통신을 처리합니다.


<br>

### TCP/IP 4계층 모델


#### 1. 링크 계층 (Link Layer):
- 역할:
  - 물리적 네트워크 연결을 관리하고, 데이터를 물리적 장치로 전송합니다.
  - 이 계층은 네트워크 인터페이스(예: 이더넷, 와이파이)를 포함합니다.
- 프로토콜:
  - Ethernet, Wi-Fi, ARP 등

<br>

#### 2. 인터넷 계층 (Internet Layer):
- 역할:
  - 데이터를 목적지 주소(IP 주소)에 따라 올바르게 라우팅하며, 패킷을 분할하고 전달합니다.
- 프로토콜:
  -  IP(Internet Protocol), ICMP, ARP

<br>

#### 3.	전송 계층 (Transport Layer):
- 역할:
  - 송수신 간의 데이터 전송을 관리하며, TCP와 UDP 같은 프로토콜을 사용해 데이터 전송의 신뢰성을 보장하거나 속도를 우선시할 수 있습니다.
- 프로토콜:
  - TCP(Transmission Control Protocol), UDP(User Datagram Protocol)

<br>

#### 4. 응용 계층 (Application Layer):
- 역할:
  - 응용 프로그램이 데이터를 주고받을 수 있도록 지원하며, HTTP, FTP 등과 같은 고수준의 프로토콜을 사용해 직접 데이터를 송수신합니다.
- 프로토콜:
  - HTTP, HTTPS, FTP, SMTP, DNS


<br>

### TCP와 UDP의 차이점
#### TCP (Transmission Control Protocol):
- 연결형 프로토콜로, 데이터의 신뢰성과 순서를 보장합니다.
- 전송 전 3-way Handshake로 연결을 설정한 후 데이터를 전송하며, 데이터가 손실되면 재전송합니다.

#### UDP (User Datagram Protocol):
- 비연결형 프로토콜로, 속도가 빠르지만 신뢰성을 보장하지 않습니다.
- 스트리밍, VoIP와 같이 데이터의 손실보다는 전송 속도가 중요한 경우에 사용됩니다.

<br>

### iOS에서의 네트워크 통신 방식
iOS는 네트워크 프로토콜 스택의 TCP/IP 계층을 기반으로 다양한 네트워크 통신 프레임워크와 API를 제공합니다. 이를 통해 개발자는 HTTP 요청, 실시간 데이터 스트리밍, 웹 소켓 등을 쉽게 구현할 수 있습니다.

<br>

#### URLSession
- 역할:
  - iOS에서 네트워크 요청을 처리하는 기본 프레임워크로, HTTP/HTTPS 통신, 파일 다운로드 및 업로드, 백그라운드 전송 등을 지원합니다.
- 특징:
  - 요청을 비동기로 처리하여, UI의 응답성을 유지하면서 데이터를 송수신할 수 있습니다.
  - 데이터 요청, 다운로드 및 업로드 작업을 지원하며, 백그라운드 전송도 가능합니다.
  - HTTP/HTTPS 프로토콜을 이용하여 REST API를 호출하거나 파일 다운로드 등과 같은 기능을 제공합니다.
- 사용 예시:
```swift
let url = URL(string: "https://jsonplaceholder.typicode.com/todos/1")!
let task = URLSession.shared.dataTask(with: url) { data, response, error in
    if let data = data {
        print(String(data: data, encoding: .utf8)!)
    }
}
task.resume()
```

<br>

### WebSocket
- 역할:
  - 클라이언트와 서버 간의 양방향 통신을 가능하게 하는 프로토콜로, 실시간 데이터 통신에 적합합니다.
- 특징:
  -	일반 HTTP 요청과 달리 지속적인 연결을 유지하여, 실시간 채팅, 주식 가격 갱신 등과 같이 지속적인 데이터 송수신이 필요한 경우에 적합합니다.
	-	iOS 13 이후 URLSession에서 기본적으로 WebSocket 지원을 제공합니다.
- 사용 예시:
```swift
if let url = URL(string: "wss://example.com/socket") {
    let webSocketTask = URLSession.shared.webSocketTask(with: url)
    webSocketTask.resume()
}
```

<br>

### Network 프레임워크
-	역할:
  -	네트워크 연결을 설정하고 관리할 수 있는 저수준 네트워크 API로, iOS 12부터 도입되었습니다.
- 특징:
  - TCP, UDP 같은 네트워크 프로토콜을 직접 제어할 수 있으며, 연결 상태나 데이터 송수신을 세부적으로 관리할 수 있습니다.
  - Peer-to-Peer 연결 및 실시간 연결에 최적화되어 있어 게임, IoT, 실시간 데이터 통신에 적합합니다.
- 사용 예시:

```swift
import Network

let connection = NWConnection(host: "example.com", port: 80, using: .tcp)
connection.start(queue: .main)
```

<br>

### MultipeerConnectivity 프레임워크
- 역할:
  - 로컬 네트워크 내에서 장치 간의 데이터 교환 및 파일 공유를 가능하게 하는 프레임워크입니다
- 특징:
  -	Bluetooth, Wi-Fi, 인프라 네트워크를 사용하여 Peer-to-Peer 연결을 지원합니다.
	-	가까운 기기 간의 채팅, 파일 공유, 멀티플레이어 게임 등에 적합합니다.
-	사용 예시:
```swift
import MultipeerConnectivity

let peerID = MCPeerID(displayName: UIDevice.current.name)
let session = MCSession(peer: peerID)
```

<br>

### iOS의 네트워크 관리 방식
- ARC를 통한 메모리 관리:
  - iOS는 URLSession 및 네트워크 객체를 ARC(Automatic Reference Counting)를 통해 관리하여 메모리 누수를 방지합니다.
- 비동기 처리:
  - 대부분의 네트워크 작업은 비동기로 처리되어, 메인 스레드의 부담을 줄이고 UI의 응답성을 유지합니다.
- 보안:
  - iOS는 **앱 전송 보안(ATS, App Transport Security)** 를 통해 HTTPS 통신을 기본 요구사항으로 설정하여, 네트워크 통신에서 데이터를 안전하게 보호합니다.

<br>

### 요약
- 네트워크 프로토콜 스택은 TCP/IP 4계층으로 구성되며, iOS는 이 스택을 기반으로 네트워크 통신을 처리합니다.
- iOS는 URLSession을 통해 HTTP/HTTPS 통신을 간편하게 지원
- WebSocket을 통해 실시간 양방향 통신을, Network 프레임워크로 저수준 네트워크 제어를 제공합니다.
- iOS의 네트워크 관리 방식은 ARC와 비동기 처리, ATS와 같은 보안 메커니즘을 통해 안정적이고 효율적인 네트워크 통신을 가능하게 합니다.

<br>
<br>

## 11. HTTP와 HTTPS의 차이점, 그리고 iOS에서의 보안 통신 방법에 대해 설명해주세요.
### HTTP와 HTTPS의 차이점
<img src="https://github.com/user-attachments/assets/a2f5238f-f201-473a-9d23-a4aed05ad067">
- HTTP는 암호화 없이 데이터를 평문으로 전송
- HTTPS는 SSL/TLS 인증서를 사용하여 데이터를 암호화하여 전송함으로써 보안성과 무결성을 보장

<br>

### iOS에서의 주요 보안 통신 방법
HTTPS 통신, ATS(App Transport Security), SSL 핀닝, 인증서 검증, 키체인(Keychain) 등이 주요한 보안 통신 방법입니다.

<br>

#### 1. HTTPS (Hypertext Transfer Protocol Secure)

- 역할 :
	- iOS에서는 네트워크 통신에 기본적으로 HTTPS를 권장합니다.
	- HTTPS는 SSL/TLS 암호화 프로토콜을 사용해 통신 데이터의 암호화, 무결성, 인증을 보장합니다.
- 특징 :
	- 데이터가 암호화되어 중간에서 도청되거나 변조될 가능성이 줄어듭니다.
- 사용자가 신뢰할 수 있는 인증서를 통해 서버의 신원을 확인할 수 있습니다.

<br>

#### 2. App Transport Security (ATS)
- 역할:
	- iOS 9 이후 도입된 **App Transport Security(ATS)** 는 앱 내 모든 네트워크 요청이 HTTPS를 사용하도록 요구하는 보안 정책입니다.
- 특징:
	- ATS는 모든 HTTP 요청을 차단하고, HTTPS를 통해 TLS 1.2 이상을 사용하도록 강제하여 보안을 강화합니다.
	- ATS 설정을 통해 특정 도메인에 대해 HTTP를 예외적으로 허용하거나, ATS를 완전히 비활성화할 수도 있지만, 이는 보안에 취약할 수 있습니다.

- ATS 예외 설정:
```swift
<key>NSAppTransportSecurity</key>
<dict>
    <key>NSExceptionDomains</key>
    <dict>
        <key>example.com</key>
        <dict>
            <key>NSIncludesSubdomains</key>
            <true/>
            <key>NSTemporaryExceptionAllowsInsecureHTTPLoads</key>
            <true/>
        </dict>
    </dict>
</dict>
```

<br>


#### 3. SSL 핀닝 (SSL Pinning)
- 역할:
	- SSL 핀닝은 앱이 특정 서버와의 연결 시 서버의 SSL 인증서를 미리 저장하고, 통신 시 이를 비교하여 신뢰성을 확인하는 방식입니다.
- 특징:
	- 중간자 공격(Man-in-the-Middle Attack)을 방지할 수 있습니다.
	- iOS에서는 URLSessionDelegate를 사용해 서버 인증서를 비교할 수 있습니다.

- SSL 핀닝 예시:
```swift
func urlSession(_ session: URLSession, didReceive challenge: URLAuthenticationChallenge,
                completionHandler: @escaping (URLSession.AuthChallengeDisposition, URLCredential?) -> Void) {
    if let serverTrust = challenge.protectionSpace.serverTrust {
        let credential = URLCredential(trust: serverTrust)
        completionHandler(.useCredential, credential)
    } else {
        completionHandler(.cancelAuthenticationChallenge, nil)
    }
}
```

<br>

#### 4. 인증서 검증
- 역할:
	- iOS에서는 HTTPS를 사용할 경우 자동으로 서버의 SSL 인증서를 검증합니다.
 	- 이를 통해 사용자는 인증서를 통해 서버의 신뢰성을 확인할 수 있습니다.
- 특징:
	- 기본적으로 URLSession은 HTTPS를 통해 서버의 인증서를 검증하여 유효한 경우에만 연결을 허용합니다.
 	- 인증서 검증을 강화하거나 특정 조건을 확인하려면 URLSessionDelegate의 didReceive challenge 메서드를 통해 추가 검증을 수행할 수 있습니다.
 
<br>

#### 5. 키체인 (Keychain)
- 역할:
	- 키체인은 iOS에서 민감한 데이터를 안전하게 저장하는 공간입니다. 예를 들어, 로그인 정보, API 토큰 등 암호화가 필요한 정보들을 키체인에 저장하여 외부로부터 보호할 수 있습니다.
- 특징:
  	- 키체인에 저장된 데이터는 암호화되며, 앱 간 공유 설정을 통해 여러 앱에서 안전하게 접근할 수 있습니다.
	- 키체인은 시스템 보안에 의해 보호되므로, 앱이 백그라운드로 전환되거나 장치가 잠기면 보안이 유지됩니다.

키체인 사용 예시:
```swift
import Security

func saveToKeychain(key: String, data: Data) {
    let query: [String: Any] = [
        kSecClass as String: kSecClassGenericPassword,
        kSecAttrAccount as String: key,
        kSecValueData as String: data
    ]
    SecItemAdd(query as CFDictionary, nil)
}

func readFromKeychain(key: String) -> Data? {
    let query: [String: Any] = [
        kSecClass as String: kSecClassGenericPassword,
        kSecAttrAccount as String: key,
        kSecReturnData as String: true,
        kSecMatchLimit as String: kSecMatchLimitOne
    ]
    var item: CFTypeRef?
    SecItemCopyMatching(query as CFDictionary, &item)
    return item as? Data
}
```

<br>

#### 6. OAuth와 토큰 기반 인증
- 역할:
	- iOS 앱에서는 OAuth2 인증을 통해 보안 통신에서 사용자의 접근 권한을 관리할 수 있습니다.
- 특징:
	- OAuth는 액세스 토큰을 사용하여, 서버와의 통신에 있어 민감한 정보를 직접 요청하지 않고 안전하게 접근할 수 있게 합니다.
	- OAuth로 인증을 수행하면 API 통신에 대한 인증 정보를 외부에 노출하지 않고 처리할 수 있습니다.

- 예시:
OAuth 인증의 과정은 인증 요청 → 액세스 토큰 수신 → 토큰을 이용한 요청의 3단계로 이루어집니다.

**1. 액세스 토큰 요청**
먼저, 클라이언트 앱은 서버에 인증 요청을 보내며, 인증이 성공하면 액세스 토큰을 반환받습니다. 이 토큰은 이후 요청에 사용됩니다.

```swift
import Foundation

func requestAccessToken(clientID: String, clientSecret: String, authorizationCode: String, redirectURI: String) {
    // 토큰 요청 URL
    let url = URL(string: "https://authorization-server.com/oauth/token")!
    var request = URLRequest(url: url)
    request.httpMethod = "POST"
    
    // 요청에 필요한 파라미터 설정
    let parameters = [
        "grant_type": "authorization_code",
        "client_id": clientID,
        "client_secret": clientSecret,
        "code": authorizationCode,
        "redirect_uri": redirectURI
    ]
    
    request.httpBody = parameters
        .map { "\($0.key)=\($0.value)" }
        .joined(separator: "&")
        .data(using: .utf8)
    
    request.setValue("application/x-www-form-urlencoded", forHTTPHeaderField: "Content-Type")

    // URLSession으로 액세스 토큰 요청
    let task = URLSession.shared.dataTask(with: request) { data, response, error in
        guard let data = data, error == nil else {
            print("Error: \(String(describing: error))")
            return
        }
        if let json = try? JSONSerialization.jsonObject(with: data, options: []) as? [String: Any] {
            let accessToken = json["access_token"] as? String
            print("Access Token: \(String(describing: accessToken))")
            // 이후 토큰을 저장하고 사용할 수 있음
        }
    }
    task.resume()
}
```

<br>

**2. 토큰을 이용한 API 요청**
액세스 토큰을 얻으면, 이를 HTTP 헤더에 포함해 서버의 보호된 리소스에 접근할 수 있습니다.
```swift
func fetchProtectedResource(withAccessToken accessToken: String) {
    let url = URL(string: "https://api.example.com/protected/resource")!
    var request = URLRequest(url: url)
    request.httpMethod = "GET"
    
    // Authorization 헤더에 액세스 토큰 추가
    request.setValue("Bearer \(accessToken)", forHTTPHeaderField: "Authorization")
    
    let task = URLSession.shared.dataTask(with: request) { data, response, error in
        guard let data = data, error == nil else {
            print("Error: \(String(describing: error))")
            return
        }
        // 보호된 리소스에 접근하여 응답 데이터 처리
        if let json = try? JSONSerialization.jsonObject(with: data, options: []) as? [String: Any] {
            print("Protected Resource Data: \(json)")
        }
    }
    task.resume()
}
```

<br>

<br>

#### 7. 기타 보안 강화 방법
- Network Extension:
	- iOS에서는 VPN을 설정하여 네트워크 보안을 강화할 수 있습니다.
- 백엔드와의 HTTPS 통신 제한:
	- iOS에서 신뢰할 수 있는 서버와의 통신만 허용하는 정책을 추가하여, 외부 서버에 대한 무단 접근을 방지할 수 있습니다.

<br>

### 요약 
iOS에서의 보안 통신은 기본적으로 HTTPS를 권장하며, ATS(App Transport Security)를 통해 HTTPS 사용을 강제하여 보안을 강화합니다. 추가적으로 SSL 핀닝, 인증서 검증을 통해 중간자 공격을 방지하고, 키체인을 통해 민감한 데이터를 안전하게 저장할 수 있습니다. 이 외에도 OAuth 인증을 통해 사용자 권한 관리를 안전하게 수행하며, 모든 방법이 협력하여 앱 내의 네트워크 통신을 보다 안전하게 유지합니다.

<br>
<br>

## 11.1 SSL/TLS의 동작 원리는 무엇인가요?
- **SSL(Secure Sockets Layer)** 와 **TLS(Transport Layer Security)** 는 네트워크 통신에서 데이터를 암호화하여 보안성을 높이기 위한 프로토콜입니다.
- TLS는 SSL의 후속 버전으로, 현재는 SSL 대신 TLS가 주로 사용됩니다.
- SSL/TLS는 클라이언트와 서버 간의 안전한 통신을 보장하기 위해 다음과 같은 절차로 동작합니다.

<br>

### 1. 핸드셰이크 단계
SSL/TLS 통신은 먼저 핸드셰이크 과정을 거쳐 보안 연결을 설정합니다. 핸드셰이크 과정은 아래와 같은 절차로 진행됩니다.

#### 1.	클라이언트 헬로(Client Hello):
- 클라이언트가 서버에 연결 요청을 하며, **지원하는 암호화 방식(암호화 스위트)** 과 TLS 버전, 랜덤 값을 서버에 전달합니다.

<br>

#### 2. 서버 헬로(Server Hello):
- 서버는 클라이언트가 지원하는 암호화 방식 중 하나를 선택하고, TLS 버전과 암호화 스위트를 클라이언트에 응답합니다. 서버 또한 랜덤 값을 클라이언트에 전달합니다.

<br>

#### 3.	서버 인증서 전송 및 검증:
- 서버는 SSL 인증서를 클라이언트에 전달하여 신뢰할 수 있는 서버임을 증명합니다.
- 이 인증서에는 서버의 공개 키가 포함되어 있습니다.
- 클라이언트는 서버의 인증서를 검증하여 유효한지 확인합니다(예: 인증서 발급 기관이 신뢰할 수 있는지, 인증서가 만료되지 않았는지 등).

<br>

#### 4.	세션 키 생성 및 교환:
- 클라이언트는 **프리마스터 시크릿(Pre-Master Secret)** 이라 불리는 임시 암호화 키를 생성하고, 서버의 공개 키로 암호화하여 서버에 전송합니다.
- 서버는 자신의 개인 키를 사용해 프리마스터 시크릿을 복호화하여 이를 얻습니다.
- 이후 클라이언트와 서버는 양측의 **랜덤 값과 프리마스터 시크릿을 사용하여 세션 키(Session Key)**  를 생성합니다.
- 이 세션 키는 대칭 암호화를 위해 사용됩니다.

<br>
 
#### 5.	완료 메시지 교환:
- 클라이언트와 서버는 변경 암호화 명령(Change Cipher Spec) 메시지를 전송하며, 이후부터는 세션 키를 사용해 데이터를 암호화합니다.
- 이 과정이 끝나면 핸드셰이크가 완료되고, 보안 통신이 시작됩니다.

<br>

### 2. 데이터 전송 단계
핸드셰이크가 완료되면 클라이언트와 서버는 대칭 암호화 방식을 사용하여 데이터 통신을 수행합니다. 이때는 세션 키를 사용해 데이터를 암호화하고 복호화하여 데이터의 기밀성을 보장합니다.

<br>

- 대칭 키 암호화 사용:
	- 세션 키를 이용한 대칭 암호화 방식은 비대칭 암호화 방식보다 속도가 빠릅니다. 따라서 대칭 암호화를 통해 실질적인 데이터 전송을 수행합니다.
- 무결성 검증:
	- SSL/TLS는 메시지 인증 코드(MAC, Message Authentication Code)를 통해 데이터가 전송 중에 변조되지 않았음을 검증합니다.

<br>

### 3. 연결 종료 단계

보안 통신이 완료되면 클라이언트와 서버는 연결을 종료합니다. 연결을 종료할 때는 세션 키도 함께 파기되며, 이후 다시 통신을 시작하려면 새로운 핸드셰이크 과정을 통해 세션 키를 설정해야 합니다.

<br>

### SSL/TLS의 주요 보안 요소
1. 기밀성(Confidentiality):
- 세션 키를 사용한 암호화를 통해 데이터를 보호하여, 외부에서 데이터 내용을 볼 수 없도록 합니다.
2. 무결성(Integrity):
- 데이터가 전송 중 변조되지 않았음을 보장하기 위해, 전송된 데이터에 대해 메시지 인증 코드를 검증합니다.
3. 인증(Authentication):
- 서버 인증서를 통해 서버의 신원을 증명하여, 신뢰할 수 있는 서버와 통신하고 있음을 보장합니다.

### 요약
- SSL/TLS의 동작은 크게 핸드셰이크 과정(인증서 검증 및 세션 키 생성)과 데이터 전송 과정(세션 키를 통한 암호화된 데이터 통신)으로 나뉩니다. 
- 핸드셰이크를 통해 클라이언트와 서버는 보안 세션 키를 공유하고, 이 키로 데이터를 암호화하여 안전하게 전송합니다. 
- 이를 통해 데이터의 기밀성, 무결성, 인증을 보장하여 안전한 네트워크 통신을 제공합니다.



<br>
<br>

## 12. **컴퓨터 네트워킹에서 OSI 7계층 모델에 대해 설명해주세요.**

### OSI 7계층 모델
#### 1.	물리 계층 (Physical Layer) - 1계층
- 역할:
  - 데이터를 전기 신호나 광신호로 변환하여 물리적으로 전송합니다.
- 장비:
  - 케이블, 허브, 리피터, 전송 매체
- 기능:
  - 비트 전송, 물리적 연결 설정 및 유지
- 예:
  - 네트워크 케이블(Ethernet), 신호 전송 방식
 
<br>

#### 2. 데이터 링크 계층 (Data Link Layer) - 2계층
- 역할:
  - 데이터 프레임을 생성하고, 오류 검출 및 수정 기능을 통해 신뢰성 있는 데이터 전송을 보장합니다.
- 장비:
  - 스위치, 브리지
- 기능:
  - 프레임 생성 및 전송, MAC 주소 기반 데이터 전송
- 예:
  - 이더넷(Ethernet), MAC 주소

<br>

#### 3.	네트워크 계층 (Network Layer) - 3계층
- 역할:
  - 데이터 패킷을 목적지까지 경로를 지정하고 라우팅하여 전송합니다.
-	장비:
  -	라우터
- 기능:
  - 라우팅, 논리적 주소(IP 주소) 할당 및 변환
- 예:
  - IP(Internet Protocol), ICMP

<br>

#### 4. 전송 계층 (Transport Layer) - 4계층
- 역할:
  - 송신자와 수신자 간의 데이터 전송을 관리하며, 데이터의 흐름과 오류 제어를 담당합니다.
- 프로토콜:
  - TCP(Transmission Control Protocol), UDP(User Datagram Protocol)
- 기능:
  - 포트 번호를 사용하여 애플리케이션에 연결, 데이터 분할 및 재조립, 흐름 및 오류 제어
-	예:
  -	TCP, UDP

<br>

 
#### 5. 세션 계층 (Session Layer) - 5계층
- 역할:
  - 송신자와 수신자 간의 세션을 설정, 유지, 종료합니다.
- 기능:
  - 세션 복구, 대화 제어
-	예:
  -	RPC(Remote Procedure Call), NetBIOS

<br>

#### 6.	표현 계층 (Presentation Layer) - 6계층
-	역할:
  -	데이터의 형식 변환 및 암호화, 압축 등을 통해 표현 형식을 변환하여 상위 계층이 데이터 형식에 구애받지 않고 통신하도록 합니다.
- 기능:
  - 데이터 변환(인코딩 및 디코딩), 암호화, 압축
-	예:
  -	JPEG, GIF, TLS, SSL

<br>

#### 7.	응용 계층 (Application Layer) - 7계층
-	역할:
  -	사용자와 네트워크 간의 직접적인 상호 작용을 제공합니다.
  -	웹 브라우저, 이메일 클라이언트 등 애플리케이션이 사용자 요청을 네트워크로 전송하도록 합니다.
- 기능:
  - 사용자 인터페이스 제공, 프로토콜 실행
-	예:
  -	HTTP, FTP, SMTP, DNS

<br>
<br>

## 12.1 TCP/IP 모델과 OSI 모델의 차이점은 무엇인가요?
<img src="https://github.com/user-attachments/assets/b821eda9-15b4-45ed-8f3a-73fee6313cbb">

- OSI 모델은 7계층으로 구성되어 있으며, 통신 표준화를 위한 이론적 모델입니다.
- TCP/IP 모델은 4계층으로 실질적인 인터넷 통신을 구현하기 위해 개발된 실무 중심의 모델입니다.
- OSI는 각 계층의 독립적인 역할과 모듈화에 중점을 두며, TCP/IP는 기능 중심의 계층 설계로 효율성과 실용성에 중점을 둡니다.

<br>
<br>

## 13. HTTP 프로토콜의 특징과 HTTP/1.1과 HTTP/2의 차이점을 설명해주세요.
    - HTTP의 무상태(Stateless) 성질은 무엇이며, 어떻게 극복하나요?
    - HTTP/2에서 추가된 주요 기능은 무엇인가요?
    - HTTP/3에서 추가된 기능은 무엇인가요?

<br>
<br>

## 14. **TCP와 UDP의 특징과 차이점에 대해 설명해주세요.**
    - 연결 지향형 프로토콜과 비연결 지향형 프로토콜은 무엇인가요?
    - TCP의 3-way handshake 과정은 어떻게 이루어지나요?
    - 어떤 상황에서 UDP를 사용하는 것이 적합한가요?

<br>
<br>

## 15. **소켓 통신에 대해 설명해주세요.**

<br>
<br>

## 16. **REST API와 iOS에서의 네트워크 요청 및 응답 처리 방법에 대해 설명해주세요.**
    - iOS에서 `URLSession`을 사용하여 네트워크 요청을 보내는 방법은 무엇인가요?

<br>
<br>

## 17. **REST API에서 HTTP 메서드들의 차이점을 설명해주세요.**
    - `GET`과 `POST`의 차이점은 무엇인가요?

<br>
<br>

## 18. **HTTP 상태 코드에 대해서 설명해주세요.**

<br>
<br>

## 19. **iOS에서 이미지 파일 포맷(PNG, JPEG 등)과 각 포맷의 특징에 대해 설명해주세요.**
    - PNG와 JPEG의 차이점은 무엇인가요?
   
<br>
<br>

## 20. **PNG 파일이 어떻게 저장되고 구성되는지 설명해주세요.**

<br>
<br>

## 21. **iOS에서 메모리 사이즈와 관련된 개념과 고려 사항에 대해 설명해주세요.**
    - 메모리 정렬(Alignment)이 성능에 미치는 영향은 무엇인가요?
   
<br>
<br>

## 22. **iOS 디바이스의 메모리 제약과 앱 메모리 제한에 대해 설명해주세요.**
    - 메모리 경고(Memory Warning)가 발생하면 어떤 조치를 취해야 하나요?
   
<br>
<br>

## 23. **알고리즘의 시간 복잡도와 공간 복잡도의 개념, 그리고 빅오 표기법에 대해 설명해주세요.**
    - O(n)과 O(log n)의 차이는 무엇인가요?
   
<br>
<br>

## 24. **자주 사용되는 정렬 알고리즘(예: 퀵 정렬, 병합 정렬)의 동작 원리와 시간 복잡도를 설명해주세요.**

<br>
<br>

## 25. **이진 탐색의 원리와 시간 복잡도에 대해 설명해주세요.**

<br>
<br>

## 26. **동적 프로그래밍(Dynamic Programming)의 개념을 설명해주세요.**

<br>
<br>

## 27. **자료구조의 종류와 iOS 개발에서 자주 사용되는 자료구조에 대해 설명해주세요.**

<br>
<br>

## 28. **배열, 연결 리스트, 스택, 큐의 특징과 iOS에서의 구현 방법을 설명해주세요.**

<br>
<br>

## 29. **해시 테이블의 개념과 충돌 해결 방법을 설명해주세요.**

<br>
<br>

## 30. **암호화와 보안의 기본 개념, 그리고 iOS 앱 보안을 위한 방안에 대해 설명해주세요.**

<br>
<br>

## 31. **가상 메모리(Virtual Memory)의 개념과 동작 원리에 대해 설명해주세요.**

<br>
<br>


## 32. **데이터베이스의 종류와 iOS에서 주로 사용되는 데이터베이스에 대해 설명해주세요.**

<br>
<br>


## 33. **싱글톤 패턴(Singleton Pattern)이란 무엇이며, 어떤 경우에 사용하나요?**

<br>
<br>


## 34. **Swift에서 싱글톤 패턴을 구현할 때 멀티스레드에 대해서 어떻게 고려해야 하나요?**


<br>
<br>
